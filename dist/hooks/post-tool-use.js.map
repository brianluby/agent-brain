{"version":3,"sources":["../../src/types.ts","../../src/utils/helpers.ts","../../src/utils/memvid-lock.ts","../../src/platforms/path-policy.ts","../../src/platforms/platform-detector.ts","../../src/core/mind.ts","../../src/utils/compression.ts","../../src/platforms/registry.ts","../../src/platforms/events.ts","../../src/platforms/adapters/create-adapter.ts","../../src/platforms/adapters/claude.ts","../../src/platforms/adapters/opencode.ts","../../src/platforms/contract.ts","../../src/platforms/diagnostics.ts","../../src/platforms/diagnostic-store.ts","../../src/platforms/identity.ts","../../src/platforms/pipeline.ts","../../src/platforms/index.ts","../../src/hooks/post-tool-use.ts"],"names":["resolve","dirname","mkdir","unlinkSync","recentObservations","exports"],"mappings":";;;;;;;;;AA6EO,IAAM,cAAA,GAA6B;AAAA,EACxC,UAAA,EAAY,kBAAA;AAAA,EACZ,sBAAA,EAAwB,EAAA;AAAA,EACxB,gBAAA,EAAkB,GAAA;AAAA,EAClB,YAAA,EAAc,IAAA;AAAA,EACd,aAAA,EAAe,GAAA;AAAA,EACf,KAAA,EAAO;AACT,CAAA;AC3EO,SAAS,UAAA,GAAqB;AACnC,EAAA,OAAO,WAAA,CAAY,CAAC,CAAA,CAAE,QAAA,CAAS,KAAK,CAAA;AACtC;AAMO,SAAS,eAAe,IAAA,EAAsB;AACnD,EAAA,OAAO,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,MAAA,GAAS,CAAC,CAAA;AAClC;AA4CA,eAAsB,SAAA,GAA6B;AACjD,EAAA,MAAM,SAAmB,EAAC;AAE1B,EAAA,OAAO,IAAI,OAAA,CAAQ,CAACA,QAAAA,EAAS,MAAA,KAAW;AACtC,IAAA,OAAA,CAAQ,KAAA,CAAM,GAAG,MAAA,EAAQ,CAAC,UAAU,MAAA,CAAO,IAAA,CAAK,KAAK,CAAC,CAAA;AACtD,IAAA,OAAA,CAAQ,KAAA,CAAM,EAAA,CAAG,KAAA,EAAO,MAAMA,QAAAA,CAAQ,MAAA,CAAO,MAAA,CAAO,MAAM,CAAA,CAAE,QAAA,CAAS,MAAM,CAAC,CAAC,CAAA;AAC7E,IAAA,OAAA,CAAQ,KAAA,CAAM,EAAA,CAAG,OAAA,EAAS,MAAM,CAAA;AAAA,EAClC,CAAC,CAAA;AACH;AAMO,SAAS,YAAY,MAAA,EAAwB;AAClD,EAAA,OAAA,CAAQ,GAAA,CAAI,IAAA,CAAK,SAAA,CAAU,MAAM,CAAC,CAAA;AAClC,EAAA,OAAA,CAAQ,KAAK,CAAC,CAAA;AAChB;AAKO,SAAS,MAAM,OAAA,EAAuB;AAC3C,EAAA,IAAI,OAAA,CAAQ,GAAA,CAAI,iBAAA,KAAsB,GAAA,EAAK;AACzC,IAAA,OAAA,CAAQ,KAAA,CAAM,CAAA,cAAA,EAAiB,OAAO,CAAA,CAAE,CAAA;AAAA,EAC1C;AACF;AAiEO,SAAS,uBAAA,CACd,UACA,MAAA,EAC2H;AAC3H,EAAA,MAAM,WAAA,GAAc,OAAO,WAAA,EAAY;AAGvC,EAAA,IACE,WAAA,CAAY,QAAA,CAAS,OAAO,CAAA,IAC5B,WAAA,CAAY,QAAA,CAAS,QAAQ,CAAA,IAC7B,WAAA,CAAY,QAAA,CAAS,WAAW,CAAA,EAChC;AACA,IAAA,OAAO,SAAA;AAAA,EACT;AAGA,EAAA,IACE,WAAA,CAAY,QAAA,CAAS,SAAS,CAAA,IAC9B,WAAA,CAAY,QAAA,CAAS,QAAQ,CAAA,IAC7B,WAAA,CAAY,QAAA,CAAS,WAAW,CAAA,EAChC;AACA,IAAA,OAAO,SAAA;AAAA,EACT;AAGA,EAAA,IAAI,YAAY,QAAA,CAAS,SAAS,KAAK,WAAA,CAAY,QAAA,CAAS,YAAY,CAAA,EAAG;AACzE,IAAA,OAAO,SAAA;AAAA,EACT;AAGA,EAAA,QAAQ,QAAA;AAAU,IAChB,KAAK,MAAA;AAAA,IACL,KAAK,MAAA;AAAA,IACL,KAAK,MAAA;AACH,MAAA,OAAO,WAAA;AAAA,IACT,KAAK,MAAA;AACH,MAAA,IAAI,YAAY,QAAA,CAAS,KAAK,KAAK,WAAA,CAAY,QAAA,CAAS,KAAK,CAAA,EAAG;AAC9D,QAAA,OAAO,QAAA;AAAA,MACT;AACA,MAAA,OAAO,UAAA;AAAA,IACT,KAAK,OAAA;AACH,MAAA,OAAO,SAAA;AAAA,IACT;AACE,MAAA,OAAO,WAAA;AAAA;AAEb;ACnMA,IAAM,YAAA,GAAe;AAAA,EACnB,KAAA,EAAO,GAAA;AAAA,EACP,OAAA,EAAS;AAAA,IACP,OAAA,EAAS,GAAA;AAAA,IACT,UAAA,EAAY,CAAA;AAAA,IACZ,UAAA,EAAY;AAAA;AAEhB,CAAA;AAEA,eAAsB,cAAA,CACpB,UACA,EAAA,EACY;AACZ,EAAA,MAAM,MAAM,OAAA,CAAQ,QAAQ,GAAG,EAAE,SAAA,EAAW,MAAM,CAAA;AAClD,EAAA,MAAM,MAAA,GAAS,MAAM,IAAA,CAAK,QAAA,EAAU,GAAG,CAAA;AACvC,EAAA,MAAM,OAAO,KAAA,EAAM;AAEnB,EAAA,MAAM,OAAA,GAAU,MAAM,QAAA,CAAS,IAAA,CAAK,UAAU,YAAY,CAAA;AAC1D,EAAA,IAAI;AACF,IAAA,OAAO,MAAM,EAAA,EAAG;AAAA,EAClB,CAAA,SAAE;AACA,IAAA,MAAM,OAAA,EAAQ;AAAA,EAChB;AACF;ACVA,SAAS,4BAA4B,QAAA,EAA0B;AAC7D,EAAA,OAAO,gBAAgB,QAAQ,CAAA,IAAA,CAAA;AACjC;AAEO,SAAS,wBAAwB,KAAA,EAAsD;AAC5F,EAAA,IAAI,MAAM,aAAA,EAAe;AACvB,IAAA,MAAM,QAAA,GAAW,KAAA,CAAM,oBAAA,IAAwB,2BAAA,CAA4B,MAAM,QAAQ,CAAA;AACzF,IAAA,OAAO;AAAA,MACL,IAAA,EAAM,iBAAA;AAAA,MACN,UAAA,EAAY,OAAA,CAAQ,KAAA,CAAM,UAAA,EAAY,QAAQ;AAAA,KAChD;AAAA,EACF;AAEA,EAAA,OAAO;AAAA,IACL,IAAA,EAAM,cAAA;AAAA,IACN,UAAA,EAAY,OAAA,CAAQ,KAAA,CAAM,UAAA,EAAY,MAAM,kBAAkB;AAAA,GAChE;AACF;;;AChCA,SAAS,kBAAkB,KAAA,EAA+C;AACxE,EAAA,IAAI,CAAC,OAAO,OAAO,MAAA;AACnB,EAAA,MAAM,UAAA,GAAa,KAAA,CAAM,IAAA,EAAK,CAAE,WAAA,EAAY;AAC5C,EAAA,OAAO,UAAA,CAAW,MAAA,GAAS,CAAA,GAAI,UAAA,GAAa,MAAA;AAC9C;AAEO,SAAS,qBAAA,GAAgC;AAC9C,EAAA,MAAM,eAAA,GAAkB,iBAAA,CAAkB,OAAA,CAAQ,GAAA,CAAI,eAAe,CAAA;AACrE,EAAA,IAAI,eAAA,EAAiB;AACnB,IAAA,OAAO,eAAA;AAAA,EACT;AAEA,EAAA,IAAI,QAAQ,GAAA,CAAI,QAAA,KAAa,OAAO,OAAA,CAAQ,GAAA,CAAI,qBAAqB,GAAA,EAAK;AACxE,IAAA,OAAO,UAAA;AAAA,EACT;AAEA,EAAA,OAAO,QAAA;AACT;AAEO,SAAS,eAAe,KAAA,EAA0B;AACvD,EAAA,MAAM,gBAAA,GAAmB,iBAAA,CAAkB,KAAA,CAAM,QAAQ,CAAA;AACzD,EAAA,IAAI,gBAAA,EAAkB;AACpB,IAAA,OAAO,gBAAA;AAAA,EACT;AAEA,EAAA,OAAO,qBAAA,EAAsB;AAC/B;;;ACIA,SAAS,YAAA,CAAa,YAAoB,SAAA,EAAyB;AACjE,EAAA,IAAI;AACF,IAAA,MAAM,GAAA,GAAMC,QAAQ,UAAU,CAAA;AAC9B,IAAA,MAAM,WAAW,UAAA,CAAW,KAAA,CAAM,GAAG,CAAA,CAAE,KAAI,IAAK,UAAA;AAChD,IAAA,MAAM,aAAA,GAAgB,IAAI,MAAA,CAAO,CAAA,CAAA,EAAI,SAAS,OAAA,CAAQ,GAAA,EAAK,KAAK,CAAC,CAAA,eAAA,CAAiB,CAAA;AAElF,IAAA,MAAM,KAAA,GAAQ,YAAY,GAAG,CAAA;AAC7B,IAAA,MAAM,OAAA,GAAU,KAAA,CACb,MAAA,CAAO,CAAA,CAAA,KAAK,aAAA,CAAc,KAAK,CAAC,CAAC,CAAA,CACjC,GAAA,CAAI,CAAA,CAAA,MAAM;AAAA,MACT,IAAA,EAAM,CAAA;AAAA,MACN,IAAA,EAAMD,OAAAA,CAAQ,GAAA,EAAK,CAAC,CAAA;AAAA,MACpB,IAAA,EAAM,SAAS,CAAA,CAAE,KAAA,CAAM,GAAG,CAAA,CAAE,GAAA,EAAI,IAAK,GAAA,EAAK,EAAE;AAAA,KAC9C,CAAE,EACD,IAAA,CAAK,CAAC,GAAG,CAAA,KAAM,CAAA,CAAE,IAAA,GAAO,CAAA,CAAE,IAAI,CAAA;AAGjC,IAAA,KAAA,IAAS,CAAA,GAAI,SAAA,EAAW,CAAA,GAAI,OAAA,CAAQ,QAAQ,CAAA,EAAA,EAAK;AAC/C,MAAA,IAAI;AACF,QAAA,UAAA,CAAW,OAAA,CAAQ,CAAC,CAAA,CAAE,IAAI,CAAA;AAC1B,QAAA,OAAA,CAAQ,MAAM,CAAA,iCAAA,EAAoC,OAAA,CAAQ,CAAC,CAAA,CAAE,IAAI,CAAA,CAAE,CAAA;AAAA,MACrE,CAAA,CAAA,MAAQ;AAAA,MAER;AAAA,IACF;AAAA,EACF,CAAA,CAAA,MAAQ;AAAA,EAER;AACF;AAGA,IAAI,SAAA,GAAY,KAAA;AAEhB,IAAI,GAAA;AAEJ,IAAI,MAAA;AAEJ,eAAe,OAAA,GAAyB;AACtC,EAAA,IAAI,SAAA,EAAW;AACf,EAAA,MAAM,GAAA,GAAM,MAAM,OAAO,aAAa,CAAA;AACtC,EAAA,GAAA,GAAM,GAAA,CAAI,GAAA;AACV,EAAA,MAAA,GAAS,GAAA,CAAI,MAAA;AACb,EAAA,SAAA,GAAY,IAAA;AACd;AAiBO,IAAM,IAAA,GAAN,MAAM,KAAA,CAAK;AAAA,EACR,MAAA;AAAA,EACA,MAAA;AAAA,EACA,UAAA;AAAA,EACA,SAAA;AAAA,EACA,WAAA,GAAc,KAAA;AAAA,EAEd,WAAA,CAAY,MAAA,EAAgB,MAAA,EAAoB,UAAA,EAAoB;AAC1E,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AACd,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AACd,IAAA,IAAA,CAAK,UAAA,GAAa,UAAA;AAClB,IAAA,IAAA,CAAK,YAAY,UAAA,EAAW;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,IAAA,CAAK,eAAA,GAAuC,EAAC,EAAkB;AAE1E,IAAA,MAAM,OAAA,EAAQ;AAEd,IAAA,MAAM,MAAA,GAAS,EAAE,GAAG,cAAA,EAAgB,GAAG,eAAA,EAAgB;AAGvD,IAAA,MAAM,UAAA,GAAa,OAAA,CAAQ,GAAA,CAAI,kBAAA,IAAsB,QAAQ,GAAA,EAAI;AACjE,IAAA,MAAM,WAAW,qBAAA,EAAsB;AACvC,IAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,GAAA,CAAI,2BAAA,KAAgC,GAAA;AAC1D,IAAA,MAAM,aAAa,uBAAA,CAAwB;AAAA,MACzC,UAAA;AAAA,MACA,QAAA;AAAA,MACA,oBAAoB,MAAA,CAAO,UAAA;AAAA,MAC3B,oBAAA,EAAsB,QAAQ,GAAA,CAAI,2BAAA;AAAA,MAClC,aAAA,EAAe;AAAA,KAChB,CAAA;AACD,IAAA,MAAM,aAAa,UAAA,CAAW,UAAA;AAC9B,IAAA,MAAM,SAAA,GAAYC,QAAQ,UAAU,CAAA;AAGpC,IAAA,MAAMC,KAAAA,CAAM,SAAA,EAAW,EAAE,SAAA,EAAW,MAAM,CAAA;AAG1C,IAAA,IAAI,MAAA;AACJ,IAAA,MAAM,gBAAA,GAAmB,GAAA;AACzB,IAAA,MAAM,QAAA,GAAW,GAAG,UAAU,CAAA,KAAA,CAAA;AAE9B,IAAA,MAAM,cAAA,CAAe,UAAU,YAAY;AACzC,MAAA,IAAI,CAAC,UAAA,CAAW,UAAU,CAAA,EAAG;AAC3B,QAAA,MAAA,GAAS,MAAM,MAAA,CAAO,UAAA,EAAY,OAAO,CAAA;AACzC,QAAA;AAAA,MACF;AAGA,MAAA,MAAM,EAAE,UAAU,UAAA,EAAY,UAAA,EAAAC,aAAW,GAAI,MAAM,OAAO,IAAS,CAAA;AACnE,MAAA,MAAM,QAAA,GAAW,QAAA,CAAS,UAAU,CAAA,CAAE,IAAA;AACtC,MAAA,MAAM,UAAA,GAAa,YAAY,IAAA,GAAO,IAAA,CAAA;AAEtC,MAAA,IAAI,aAAa,gBAAA,EAAkB;AACjC,QAAA,OAAA,CAAQ,MAAM,CAAA,qCAAA,EAAwC,UAAA,CAAW,OAAA,CAAQ,CAAC,CAAC,CAAA,+CAAA,CAAiD,CAAA;AAC5H,QAAA,MAAM,aAAa,CAAA,EAAG,UAAU,CAAA,QAAA,EAAW,IAAA,CAAK,KAAK,CAAA,CAAA;AACrD,QAAA,IAAI;AAAE,UAAA,UAAA,CAAW,YAAY,UAAU,CAAA;AAAA,QAAG,CAAA,CAAA,MAAQ;AAAA,QAAe;AACjE,QAAA,MAAA,GAAS,MAAM,MAAA,CAAO,UAAA,EAAY,OAAO,CAAA;AACzC,QAAA;AAAA,MACF;AAEA,MAAA,IAAI;AACF,QAAA,MAAA,GAAS,MAAM,GAAA,CAAI,OAAA,EAAS,UAAU,CAAA;AAAA,MACxC,SAAS,SAAA,EAAoB;AAC3B,QAAA,MAAM,eAAe,SAAA,YAAqB,KAAA,GAAQ,SAAA,CAAU,OAAA,GAAU,OAAO,SAAS,CAAA;AAEtF,QAAA,IAAI,YAAA,CAAa,QAAA,CAAS,iBAAiB,CAAA,IACvC,YAAA,CAAa,QAAA,CAAS,mBAAmB,CAAA,IACzC,YAAA,CAAa,QAAA,CAAS,SAAS,CAAA,IAC/B,YAAA,CAAa,QAAA,CAAS,SAAS,CAAA,IAC/B,YAAA,CAAa,QAAA,CAAS,mBAAmB,CAAA,IACzC,YAAA,CAAa,QAAA,CAAS,mBAAmB,CAAA,IACzC,YAAA,CAAa,QAAA,CAAS,mBAAmB,CAAA,EAAG;AAC9C,UAAA,OAAA,CAAQ,MAAM,+DAA+D,CAAA;AAC7E,UAAA,MAAM,aAAa,CAAA,EAAG,UAAU,CAAA,QAAA,EAAW,IAAA,CAAK,KAAK,CAAA,CAAA;AACrD,UAAA,IAAI;AACF,YAAA,UAAA,CAAW,YAAY,UAAU,CAAA;AAAA,UACnC,CAAA,CAAA,MAAQ;AACN,YAAA,IAAI;AAAE,cAAAA,YAAW,UAAU,CAAA;AAAA,YAAG,CAAA,CAAA,MAAQ;AAAA,YAAe;AAAA,UACvD;AACA,UAAA,MAAA,GAAS,MAAM,MAAA,CAAO,UAAA,EAAY,OAAO,CAAA;AACzC,UAAA;AAAA,QACF;AACA,QAAA,MAAM,SAAA;AAAA,MACR;AAAA,IACF,CAAC,CAAA;AAED,IAAA,MAAM,IAAA,GAAO,IAAI,KAAA,CAAK,MAAA,EAAQ,QAAQ,UAAU,CAAA;AAChD,IAAA,IAAA,CAAK,WAAA,GAAc,IAAA;AAGnB,IAAA,YAAA,CAAa,YAAY,CAAC,CAAA;AAE1B,IAAA,IAAI,OAAO,KAAA,EAAO;AAChB,MAAA,OAAA,CAAQ,KAAA,CAAM,CAAA,sBAAA,EAAyB,UAAU,CAAA,CAAE,CAAA;AAAA,IACrD;AAEA,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,MAAc,SAAY,EAAA,EAAkC;AAC1D,IAAA,MAAM,UAAA,GAAa,KAAK,aAAA,EAAc;AACtC,IAAA,MAAM,QAAA,GAAW,GAAG,UAAU,CAAA,KAAA,CAAA;AAC9B,IAAA,OAAO,cAAA,CAAe,UAAU,EAAE,CAAA;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS,KAAA,EAMK;AAClB,IAAA,MAAM,WAAA,GAA2B;AAAA,MAC/B,IAAI,UAAA,EAAW;AAAA,MACf,SAAA,EAAW,KAAK,GAAA,EAAI;AAAA,MACpB,MAAM,KAAA,CAAM,IAAA;AAAA,MACZ,MAAM,KAAA,CAAM,IAAA;AAAA,MACZ,SAAS,KAAA,CAAM,OAAA;AAAA,MACf,SAAS,KAAA,CAAM,OAAA;AAAA,MACf,QAAA,EAAU;AAAA,QACR,GAAG,KAAA,CAAM,QAAA;AAAA,QACT,WAAW,IAAA,CAAK;AAAA;AAClB,KACF;AAEA,IAAA,MAAM,OAAA,GAAU,MAAM,IAAA,CAAK,QAAA,CAAS,YAAY;AAC9C,MAAA,OAAO,IAAA,CAAK,OAAO,GAAA,CAAI;AAAA,QACrB,OAAO,CAAA,CAAA,EAAI,WAAA,CAAY,IAAI,CAAA,EAAA,EAAK,YAAY,OAAO,CAAA,CAAA;AAAA,QACnD,OAAO,WAAA,CAAY,IAAA;AAAA,QACnB,MAAM,WAAA,CAAY,OAAA;AAAA,QAClB,QAAA,EAAU;AAAA,UACR,eAAe,WAAA,CAAY,EAAA;AAAA,UAC3B,WAAW,WAAA,CAAY,SAAA;AAAA,UACvB,MAAM,WAAA,CAAY,IAAA;AAAA,UAClB,WAAW,IAAA,CAAK,SAAA;AAAA,UAChB,GAAG,WAAA,CAAY;AAAA,SACjB;AAAA,QACA,IAAA,EAAM,CAAC,WAAA,CAAY,IAAA,EAAM,YAAY,IAAI,CAAA,CAAE,OAAO,OAAO;AAAA,OAC1D,CAAA;AAAA,IACH,CAAC,CAAA;AAED,IAAA,IAAI,IAAA,CAAK,OAAO,KAAA,EAAO;AACrB,MAAA,OAAA,CAAQ,KAAA,CAAM,CAAA,0BAAA,EAA6B,WAAA,CAAY,OAAO,CAAA,CAAE,CAAA;AAAA,IAClE;AAEA,IAAA,OAAO,OAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAA,CAAO,KAAA,EAAe,KAAA,GAAQ,EAAA,EAAmC;AACrE,IAAA,OAAO,IAAA,CAAK,SAAS,YAAY;AAC/B,MAAA,OAAO,IAAA,CAAK,cAAA,CAAe,KAAA,EAAO,KAAK,CAAA;AAAA,IACzC,CAAC,CAAA;AAAA,EACH;AAAA,EAEA,MAAc,cAAA,CAAe,KAAA,EAAe,KAAA,EAA8C;AACxF,IAAA,MAAM,OAAA,GAAU,MAAM,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,KAAA,EAAO,EAAE,CAAA,EAAG,KAAA,EAAO,IAAA,EAAM,KAAA,EAAO,CAAA;AAEvE,IAAA,OAAA,CAAQ,QAAQ,MAAA,IAAU,EAAC,EAAG,GAAA,CAAI,CAAC,KAAA,MAAgB;AAAA,MACjD,WAAA,EAAa;AAAA,QACX,EAAA,EAAI,KAAA,CAAM,QAAA,EAAU,aAAA,IAAiB,KAAA,CAAM,QAAA;AAAA,QAC3C,SAAA,EAAW,KAAA,CAAM,QAAA,EAAU,SAAA,IAAa,CAAA;AAAA,QACxC,MAAM,KAAA,CAAM,KAAA;AAAA,QACZ,IAAA,EAAM,MAAM,QAAA,EAAU,IAAA;AAAA,QACtB,SAAS,KAAA,CAAM,KAAA,EAAO,OAAA,CAAQ,aAAA,EAAe,EAAE,CAAA,IAAK,EAAA;AAAA,QACpD,OAAA,EAAS,MAAM,IAAA,IAAQ,EAAA;AAAA,QACvB,UAAU,KAAA,CAAM;AAAA,OAClB;AAAA,MACA,KAAA,EAAO,MAAM,KAAA,IAAS,CAAA;AAAA,MACtB,OAAA,EAAS,MAAM,OAAA,IAAW,KAAA,CAAM,MAAM,KAAA,CAAM,CAAA,EAAG,GAAG,CAAA,IAAK;AAAA,KACzD,CAAE,CAAA;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAI,QAAA,EAAmC;AAC3C,IAAA,OAAO,IAAA,CAAK,SAAS,YAAY;AAC/B,MAAA,MAAM,MAAA,GAAS,MAAM,IAAA,CAAK,MAAA,CAAO,GAAA,CAAI,QAAA,EAAU,EAAE,CAAA,EAAG,CAAA,EAAG,IAAA,EAAM,KAAA,EAAO,CAAA;AACpE,MAAA,OAAO,OAAO,MAAA,IAAU,6BAAA;AAAA,IAC1B,CAAC,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAAW,KAAA,EAA0C;AACzD,IAAA,OAAO,IAAA,CAAK,SAAS,YAAY;AAE/B,MAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS;AAAA,QAC1C,KAAA,EAAO,KAAK,MAAA,CAAO,sBAAA;AAAA,QACnB,OAAA,EAAS;AAAA,OACV,CAAA;AAGD,MAAA,MAAM,MAAA,GAAS,MAAM,OAAA,CAAQ,QAAQ,IAAI,QAAA,GAAY,QAAA,CAAS,UAAU,EAAC;AAEzE,MAAA,MAAMC,sBAAoC,MAAA,CAAO,GAAA;AAAA,QAC/C,CAAC,KAAA,KAAe;AAEd,UAAA,IAAI,EAAA,GAAK,KAAA,CAAM,QAAA,EAAU,SAAA,IAAa,MAAM,SAAA,IAAa,CAAA;AAEzD,UAAA,IAAI,EAAA,GAAK,CAAA,IAAK,EAAA,GAAK,UAAA,EAAY;AAC7B,YAAA,EAAA,GAAK,EAAA,GAAK,GAAA;AAAA,UACZ;AACA,UAAA,OAAO;AAAA,YACL,EAAA,EAAI,KAAA,CAAM,QAAA,EAAU,aAAA,IAAiB,KAAA,CAAM,QAAA;AAAA,YAC3C,SAAA,EAAW,EAAA;AAAA,YACX,IAAA,EAAO,KAAA,CAAM,KAAA,IAAS,KAAA,CAAM,UAAU,IAAA,IAAQ,aAAA;AAAA,YAC9C,IAAA,EAAM,MAAM,QAAA,EAAU,IAAA;AAAA,YACtB,OAAA,EAAS,KAAA,CAAM,KAAA,EAAO,OAAA,CAAQ,aAAA,EAAe,EAAE,CAAA,IAAK,KAAA,CAAM,OAAA,EAAS,KAAA,CAAM,CAAA,EAAG,GAAG,CAAA,IAAK,EAAA;AAAA,YACpF,OAAA,EAAS,KAAA,CAAM,IAAA,IAAQ,KAAA,CAAM,OAAA,IAAW,EAAA;AAAA,YACxC,UAAU,KAAA,CAAM;AAAA,WAClB;AAAA,QACF;AAAA,OACF;AAGA,MAAA,IAAI,mBAAkC,EAAC;AACvC,MAAA,IAAI,KAAA,EAAO;AACT,QAAA,MAAM,aAAA,GAAgB,MAAM,IAAA,CAAK,cAAA,CAAe,OAAO,EAAE,CAAA;AACzD,QAAA,gBAAA,GAAmB,aAAA,CAAc,GAAA,CAAI,CAAC,CAAA,KAAM,EAAE,WAAW,CAAA;AAAA,MAC3D;AAIA,MAAA,IAAI,UAAA,GAAa,CAAA;AAGjB,MAAA,KAAA,MAAW,OAAOA,mBAAAA,EAAoB;AACpC,QAAA,MAAM,OAAO,CAAA,CAAA,EAAI,GAAA,CAAI,IAAI,CAAA,EAAA,EAAK,IAAI,OAAO,CAAA,CAAA;AACzC,QAAA,MAAM,MAAA,GAAS,eAAe,IAAI,CAAA;AAClC,QAAA,IAAI,UAAA,GAAa,MAAA,GAAS,IAAA,CAAK,MAAA,CAAO,gBAAA,EAAkB;AAExD,QAAA,UAAA,IAAc,MAAA;AAAA,MAChB;AAEA,MAAA,OAAO;AAAA,QACL,kBAAA,EAAAA,mBAAAA;AAAA,QACA,gBAAA;AAAA,QACA,kBAAkB,EAAC;AAAA;AAAA,QACnB;AAAA,OACF;AAAA,IACF,CAAC,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAmB,OAAA,EAIL;AAClB,IAAA,MAAM,cAAA,GAAiC;AAAA,MACrC,IAAI,IAAA,CAAK,SAAA;AAAA,MACT,SAAA,EAAW,IAAA,CAAK,GAAA,EAAI,GAAI,IAAA;AAAA;AAAA,MACxB,OAAA,EAAS,KAAK,GAAA,EAAI;AAAA,MAClB,gBAAA,EAAkB,CAAA;AAAA;AAAA,MAClB,cAAc,OAAA,CAAQ,YAAA;AAAA,MACtB,eAAe,OAAA,CAAQ,aAAA;AAAA,MACvB,SAAS,OAAA,CAAQ;AAAA,KACnB;AAEA,IAAA,OAAO,IAAA,CAAK,SAAS,YAAY;AAC/B,MAAA,OAAO,IAAA,CAAK,OAAO,GAAA,CAAI;AAAA,QACrB,KAAA,EAAO,CAAA,iBAAA,EAAA,iBAAoB,IAAI,IAAA,EAAK,EAAE,WAAA,EAAY,CAAE,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAC,CAAA,CAAA;AAAA,QACjE,KAAA,EAAO,SAAA;AAAA,QACP,IAAA,EAAM,IAAA,CAAK,SAAA,CAAU,cAAA,EAAgB,MAAM,CAAC,CAAA;AAAA,QAC5C,QAAA,EAAU,cAAA;AAAA,QACV,IAAA,EAAM,CAAC,SAAA,EAAW,SAAS;AAAA,OAC5B,CAAA;AAAA,IACH,CAAC,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAA,GAA4B;AAChC,IAAA,OAAO,IAAA,CAAK,SAAS,YAAY;AAC/B,MAAA,MAAM,KAAA,GAAQ,MAAM,IAAA,CAAK,MAAA,CAAO,KAAA,EAAM;AACtC,MAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,EAAE,KAAA,EAAO,CAAA,EAAG,OAAA,EAAS,KAAA,EAAO,CAAA;AACxE,MAAA,MAAM,cAAA,GAAiB,MAAM,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,EAAE,KAAA,EAAO,CAAA,EAAG,OAAA,EAAS,IAAA,EAAM,CAAA;AAG7E,MAAA,MAAM,YAAA,GAAe,MAAM,OAAA,CAAQ,QAAQ,IAAI,QAAA,GAAY,QAAA,CAAS,UAAU,EAAC;AAC/E,MAAA,MAAM,YAAA,GAAe,MAAM,OAAA,CAAQ,cAAc,IAAI,cAAA,GAAkB,cAAA,CAAe,UAAU,EAAC;AAEjG,MAAA,OAAO;AAAA,QACL,iBAAA,EAAoB,MAAM,WAAA,IAA0B,CAAA;AAAA,QACpD,aAAA,EAAe,CAAA;AAAA;AAAA,QACf,YAAA,EAAe,aAAa,CAAC,CAAA,EAAW,UAAU,SAAA,IAAc,YAAA,CAAa,CAAC,CAAA,EAAW,SAAA,IAAa,CAAA;AAAA,QACtG,YAAA,EAAe,aAAa,CAAC,CAAA,EAAW,UAAU,SAAA,IAAc,YAAA,CAAa,CAAC,CAAA,EAAW,SAAA,IAAa,CAAA;AAAA,QACtG,QAAA,EAAW,MAAM,UAAA,IAAyB,CAAA;AAAA,QAC1C,UAAU;AAAC;AAAA,OACb;AAAA,IACF,CAAC,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,YAAA,GAAuB;AACrB,IAAA,OAAO,IAAA,CAAK,SAAA;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,aAAA,GAAwB;AACtB,IAAA,OAAO,IAAA,CAAK,UAAA;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,aAAA,GAAyB;AACvB,IAAA,OAAO,IAAA,CAAK,WAAA;AAAA,EACd;AACF,CAAA;AAGA,IAAI,YAAA,GAA4B,IAAA;AAKhC,eAAsB,QAAQ,MAAA,EAA6C;AACzE,EAAA,IAAI,CAAC,YAAA,EAAc;AACjB,IAAA,YAAA,GAAe,MAAM,IAAA,CAAK,IAAA,CAAK,MAAM,CAAA;AAAA,EACvC;AACA,EAAA,OAAO,YAAA;AACT;;;ACzaA,IAAM,sBAAA,GAAyB,GAAA;AAG/B,IAAM,qBAAA,GAAwB,GAAA;AAKvB,SAAS,kBAAA,CACd,QAAA,EACA,SAAA,EACA,MAAA,EACsE;AACtE,EAAA,MAAM,eAAe,MAAA,CAAO,MAAA;AAG5B,EAAA,IAAI,gBAAgB,qBAAA,EAAuB;AACzC,IAAA,OAAO,EAAE,UAAA,EAAY,MAAA,EAAQ,aAAA,EAAe,OAAO,YAAA,EAAa;AAAA,EAClE;AAEA,EAAA,IAAI,UAAA;AAEJ,EAAA,QAAQ,QAAA;AAAU,IAChB,KAAK,MAAA;AACH,MAAA,UAAA,GAAa,gBAAA,CAAiB,WAAW,MAAM,CAAA;AAC/C,MAAA;AAAA,IACF,KAAK,MAAA;AACH,MAAA,UAAA,GAAa,kBAAA,CAAmB,WAAW,MAAM,CAAA;AACjD,MAAA;AAAA,IACF,KAAK,MAAA;AACH,MAAA,UAAA,GAAa,kBAAA,CAAmB,WAAW,MAAM,CAAA;AACjD,MAAA;AAAA,IACF,KAAK,MAAA;AACH,MAAA,UAAA,GAAa,kBAAA,CAAmB,WAAW,MAAM,CAAA;AACjD,MAAA;AAAA,IACF,KAAK,MAAA;AAAA,IACL,KAAK,OAAA;AACH,MAAA,UAAA,GAAa,kBAAA,CAAmB,WAAW,MAAM,CAAA;AACjD,MAAA;AAAA,IACF;AACE,MAAA,UAAA,GAAa,gBAAgB,MAAM,CAAA;AAAA;AAGvC,EAAA,OAAO;AAAA,IACL,UAAA,EAAY,iBAAiB,UAAU,CAAA;AAAA,IACvC,aAAA,EAAe,IAAA;AAAA,IACf;AAAA,GACF;AACF;AAKA,SAAS,gBAAA,CACP,WACA,MAAA,EACQ;AACR,EAAA,MAAM,QAAA,GAAY,WAAW,SAAA,IAAwB,SAAA;AACrD,EAAA,MAAM,WAAW,QAAA,CAAS,KAAA,CAAM,GAAG,CAAA,CAAE,KAAI,IAAK,MAAA;AAC9C,EAAA,MAAM,KAAA,GAAQ,MAAA,CAAO,KAAA,CAAM,IAAI,CAAA;AAC/B,EAAA,MAAM,aAAa,KAAA,CAAM,MAAA;AAGzB,EAAA,MAAM,OAAA,GAAU,eAAe,MAAM,CAAA;AACrC,EAAA,MAAMC,SAAA,GAAU,eAAe,MAAM,CAAA;AACrC,EAAA,MAAM,SAAA,GAAY,0BAA0B,MAAM,CAAA;AAClD,EAAA,MAAM,OAAA,GAAU,kBAAkB,MAAM,CAAA;AACxC,EAAA,MAAM,MAAA,GAAS,qBAAqB,MAAM,CAAA;AAE1C,EAAA,MAAM,KAAA,GAAkB;AAAA,IACtB,CAAA,gBAAA,EAAY,QAAQ,CAAA,EAAA,EAAK,UAAU,CAAA,OAAA;AAAA,GACrC;AAEA,EAAA,IAAI,OAAA,CAAQ,SAAS,CAAA,EAAG;AACtB,IAAA,KAAA,CAAM,IAAA,CAAK;AAAA,mBAAA,EAAiB,QAAQ,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA,EAAG,OAAA,CAAQ,MAAA,GAAS,KAAK,CAAA,GAAA,EAAM,OAAA,CAAQ,SAAS,EAAE,CAAA,MAAA,CAAA,GAAW,EAAE,CAAA,CAAE,CAAA;AAAA,EAC9H;AAEA,EAAA,IAAIA,SAAA,CAAQ,SAAS,CAAA,EAAG;AACtB,IAAA,KAAA,CAAM,IAAA,CAAK;AAAA,mBAAA,EAAiBA,UAAQ,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA,EAAGA,SAAA,CAAQ,MAAA,GAAS,KAAK,CAAA,GAAA,EAAMA,SAAA,CAAQ,SAAS,EAAE,CAAA,MAAA,CAAA,GAAW,EAAE,CAAA,CAAE,CAAA;AAAA,EAC9H;AAEA,EAAA,IAAI,SAAA,CAAU,SAAS,CAAA,EAAG;AACxB,IAAA,KAAA,CAAM,IAAA,CAAK;AAAA,kBAAA,EAAkB,UAAU,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA,EAAG,SAAA,CAAU,MAAA,GAAS,KAAK,CAAA,GAAA,EAAM,SAAA,CAAU,SAAS,EAAE,CAAA,MAAA,CAAA,GAAW,EAAE,CAAA,CAAE,CAAA;AAAA,EACrI;AAEA,EAAA,IAAI,OAAA,CAAQ,SAAS,CAAA,EAAG;AACtB,IAAA,KAAA,CAAM,IAAA,CAAK;AAAA,yBAAA,EAAkB,OAAA,CAAQ,IAAA,CAAK,IAAI,CAAC,CAAA,CAAE,CAAA;AAAA,EACnD;AAEA,EAAA,IAAI,MAAA,CAAO,SAAS,CAAA,EAAG;AACrB,IAAA,KAAA,CAAM,IAAA,CAAK;AAAA,2BAAA,EAAsB,MAAA,CAAO,MAAM,CAAA,EAAG,CAAC,EAAE,IAAA,CAAK,IAAI,CAAC,CAAA,CAAE,CAAA;AAAA,EAClE;AAGA,EAAA,MAAM,YAAA,GAAe;AAAA,IACnB,0BAAA;AAAA,IACA,GAAG,KAAA,CAAM,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA;AAAA,IACpB,wBAAA;AAAA,IACA,GAAG,KAAA,CAAM,KAAA,CAAM,EAAE;AAAA,GACnB;AAEA,EAAA,KAAA,CAAM,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,IAAI,CAAC,CAAA;AAElC,EAAA,OAAO,KAAA,CAAM,KAAK,EAAE,CAAA;AACtB;AAKA,SAAS,kBAAA,CACP,WACA,MAAA,EACQ;AACR,EAAA,MAAM,OAAA,GAAW,WAAW,OAAA,IAAsB,SAAA;AAClD,EAAA,MAAM,QAAA,GAAW,QAAQ,KAAA,CAAM,IAAI,EAAE,CAAC,CAAA,CAAE,KAAA,CAAM,CAAA,EAAG,GAAG,CAAA;AACpD,EAAA,MAAM,KAAA,GAAQ,MAAA,CAAO,KAAA,CAAM,IAAI,CAAA;AAG/B,EAAA,MAAM,aAAa,KAAA,CAAM,MAAA;AAAA,IACvB,CAAC,CAAA,KACC,CAAA,CAAE,WAAA,EAAY,CAAE,SAAS,OAAO,CAAA,IAChC,CAAA,CAAE,WAAA,EAAY,CAAE,QAAA,CAAS,QAAQ,CAAA,IACjC,CAAA,CAAE,WAAA,EAAY,CAAE,QAAA,CAAS,WAAW,KACpC,CAAA,CAAE,WAAA,EAAY,CAAE,QAAA,CAAS,SAAS;AAAA,GACtC;AAGA,EAAA,MAAM,eAAe,KAAA,CAAM,MAAA;AAAA,IACzB,CAAC,CAAA,KACC,CAAA,CAAE,WAAA,EAAY,CAAE,SAAS,SAAS,CAAA,IAClC,CAAA,CAAE,WAAA,EAAY,CAAE,QAAA,CAAS,QAAQ,CAAA,IACjC,CAAA,CAAE,WAAA,EAAY,CAAE,QAAA,CAAS,WAAW,KACpC,CAAA,CAAE,WAAA,EAAY,CAAE,QAAA,CAAS,MAAM;AAAA,GACnC;AAEA,EAAA,MAAM,KAAA,GAAkB,CAAC,CAAA,yBAAA,EAAgB,QAAQ,CAAA,CAAE,CAAA;AAEnD,EAAA,IAAI,UAAA,CAAW,SAAS,CAAA,EAAG;AACzB,IAAA,KAAA,CAAM,IAAA,CAAK;AAAA,eAAA,EAAe,UAAA,CAAW,MAAM,CAAA,EAAA,CAAI,CAAA;AAC/C,IAAA,KAAA,CAAM,IAAA,CAAK,WAAW,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA;AAAA,EAC/C;AAEA,EAAA,IAAI,YAAA,CAAa,SAAS,CAAA,EAAG;AAC3B,IAAA,KAAA,CAAM,IAAA,CAAK;AAAA,0BAAA,CAAyB,CAAA;AACpC,IAAA,KAAA,CAAM,IAAA,CAAK,aAAa,KAAA,CAAM,CAAA,EAAG,CAAC,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA;AAAA,EAChD;AAGA,EAAA,KAAA,CAAM,IAAA,CAAK;AAAA,kBAAA,EAAgB,KAAA,CAAM,MAAM,CAAA,YAAA,CAAc,CAAA;AAGrD,EAAA,IAAI,KAAA,CAAM,SAAS,EAAA,EAAI;AACrB,IAAA,KAAA,CAAM,KAAK,0BAA0B,CAAA;AACrC,IAAA,KAAA,CAAM,IAAA,CAAK,MAAM,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA;AACxC,IAAA,KAAA,CAAM,KAAK,wBAAwB,CAAA;AACnC,IAAA,KAAA,CAAM,KAAK,KAAA,CAAM,KAAA,CAAM,EAAE,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA;AAAA,EACvC,CAAA,MAAO;AACL,IAAA,KAAA,CAAM,KAAK,uBAAuB,CAAA;AAClC,IAAA,KAAA,CAAM,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,IAAI,CAAC,CAAA;AAAA,EAC7B;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,EAAE,CAAA;AACtB;AAKA,SAAS,kBAAA,CACP,WACA,MAAA,EACQ;AACR,EAAA,MAAM,OAAA,GAAW,WAAW,OAAA,IAAsB,SAAA;AAClD,EAAA,MAAM,QAAQ,MAAA,CAAO,KAAA,CAAM,IAAI,CAAA,CAAE,OAAO,OAAO,CAAA;AAG/C,EAAA,MAAM,KAAA,uBAAY,GAAA,EAAY;AAC9B,EAAA,KAAA,CAAM,OAAA,CAAQ,CAAC,IAAA,KAAS;AACtB,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,WAAW,CAAA;AACpC,IAAA,IAAI,KAAA,EAAO,KAAA,CAAM,GAAA,CAAI,KAAA,CAAM,CAAC,CAAC,CAAA;AAAA,EAC/B,CAAC,CAAA;AAED,EAAA,MAAM,KAAA,GAAkB;AAAA,IACtB,CAAA,iBAAA,EAAa,OAAA,CAAQ,KAAA,CAAM,CAAA,EAAG,EAAE,CAAC,CAAA,CAAA,CAAA;AAAA,IACjC,CAAA,mBAAA,EAAe,KAAA,CAAM,IAAI,CAAA,QAAA,EAAW,MAAM,MAAM,CAAA,QAAA;AAAA,GAClD;AAEA,EAAA,IAAI,KAAA,CAAM,OAAO,CAAA,EAAG;AAClB,IAAA,KAAA,CAAM,IAAA,CAAK;AAAA,iBAAA,EAAe,KAAA,CAAM,KAAK,KAAK,CAAA,CAAE,MAAM,CAAA,EAAG,EAAE,EAAE,IAAA,CAAK,IAAI,CAAC,CAAA,EAAG,KAAA,CAAM,OAAO,EAAA,GAAK,CAAA,GAAA,EAAM,MAAM,IAAA,GAAO,EAAE,CAAA,MAAA,CAAA,GAAW,EAAE,CAAA,CAAE,CAAA;AAAA,EAC9H;AAGA,EAAA,KAAA,CAAM,KAAK,uBAAuB,CAAA;AAClC,EAAA,KAAA,CAAM,IAAA,CAAK,MAAM,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA;AAExC,EAAA,IAAI,KAAA,CAAM,SAAS,EAAA,EAAI;AACrB,IAAA,KAAA,CAAM,IAAA,CAAK;AAAA,QAAA,EAAa,KAAA,CAAM,MAAA,GAAS,EAAE,CAAA,aAAA,CAAe,CAAA;AAAA,EAC1D;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,EAAE,CAAA;AACtB;AAKA,SAAS,kBAAA,CACP,WACA,MAAA,EACQ;AACR,EAAA,MAAM,OAAA,GAAW,WAAW,OAAA,IAAsB,SAAA;AAGlD,EAAA,IAAI,QAAkB,EAAC;AACvB,EAAA,IAAI;AACF,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,KAAA,CAAM,MAAM,CAAA;AAChC,IAAA,KAAA,GAAQ,MAAA,CAAO,aAAa,EAAC;AAAA,EAC/B,CAAA,CAAA,MAAQ;AACN,IAAA,KAAA,GAAQ,MAAA,CAAO,KAAA,CAAM,IAAI,CAAA,CAAE,OAAO,OAAO,CAAA;AAAA,EAC3C;AAGA,EAAA,MAAM,QAAkC,EAAC;AACzC,EAAA,KAAA,CAAM,OAAA,CAAQ,CAAC,CAAA,KAAM;AACnB,IAAA,MAAM,GAAA,GAAM,CAAA,CAAE,KAAA,CAAM,GAAG,CAAA,CAAE,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA,IAAK,GAAA;AACnD,IAAA,MAAM,OAAO,CAAA,CAAE,KAAA,CAAM,GAAG,CAAA,CAAE,KAAI,IAAK,CAAA;AACnC,IAAA,IAAI,CAAC,KAAA,CAAM,GAAG,GAAG,KAAA,CAAM,GAAG,IAAI,EAAC;AAC/B,IAAA,KAAA,CAAM,GAAG,CAAA,CAAE,IAAA,CAAK,IAAI,CAAA;AAAA,EACtB,CAAC,CAAA;AAED,EAAA,MAAM,KAAA,GAAkB;AAAA,IACtB,CAAA,iBAAA,EAAa,OAAA,CAAQ,KAAA,CAAM,CAAA,EAAG,EAAE,CAAC,CAAA,CAAA,CAAA;AAAA,IACjC,CAAA,gBAAA,EAAY,MAAM,MAAM,CAAA,UAAA,EAAa,OAAO,IAAA,CAAK,KAAK,EAAE,MAAM,CAAA,YAAA;AAAA,GAChE;AAGA,EAAA,MAAM,OAAA,GAAU,OAAO,OAAA,CAAQ,KAAK,EACjC,IAAA,CAAK,CAAC,GAAG,CAAA,KAAM,CAAA,CAAE,CAAC,CAAA,CAAE,MAAA,GAAS,EAAE,CAAC,CAAA,CAAE,MAAM,CAAA,CACxC,KAAA,CAAM,GAAG,CAAC,CAAA;AAEb,EAAA,KAAA,CAAM,KAAK,2BAA2B,CAAA;AACtC,EAAA,OAAA,CAAQ,OAAA,CAAQ,CAAC,CAAC,GAAA,EAAK,QAAQ,CAAA,KAAM;AACnC,IAAA,MAAM,QAAA,GAAW,IAAI,KAAA,CAAM,GAAG,EAAE,KAAA,CAAM,EAAE,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA;AAClD,IAAA,KAAA,CAAM,KAAK,CAAA,EAAG,QAAQ,CAAA,GAAA,EAAM,QAAA,CAAS,MAAM,CAAA,OAAA,CAAS,CAAA;AAAA,EACtD,CAAC,CAAA;AAGD,EAAA,KAAA,CAAM,KAAK,wBAAwB,CAAA;AACnC,EAAA,KAAA,CAAM,KAAK,KAAA,CAAM,KAAA,CAAM,GAAG,EAAE,CAAA,CAAE,IAAI,CAAC,CAAA,KAAM,CAAA,CAAE,KAAA,CAAM,GAAG,CAAA,CAAE,GAAA,EAAK,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA;AAEvE,EAAA,OAAO,KAAA,CAAM,KAAK,EAAE,CAAA;AACtB;AAKA,SAAS,kBAAA,CACP,WACA,MAAA,EACQ;AACR,EAAA,MAAM,QAAA,GAAY,WAAW,SAAA,IAAwB,SAAA;AACrD,EAAA,MAAM,WAAW,QAAA,CAAS,KAAA,CAAM,GAAG,CAAA,CAAE,KAAI,IAAK,MAAA;AAE9C,EAAA,OAAO;AAAA,IACL,wBAAc,QAAQ,CAAA,CAAA;AAAA,IACtB,CAAA,sCAAA,CAAA;AAAA,IACA,MAAA,CAAO,KAAA,CAAM,CAAA,EAAG,GAAG;AAAA,GACrB,CAAE,KAAK,IAAI,CAAA;AACb;AAKA,SAAS,gBAAgB,MAAA,EAAwB;AAC/C,EAAA,MAAM,KAAA,GAAQ,MAAA,CAAO,KAAA,CAAM,IAAI,CAAA;AAE/B,EAAA,IAAI,KAAA,CAAM,UAAU,EAAA,EAAI;AACtB,IAAA,OAAO,MAAA;AAAA,EACT;AAEA,EAAA,OAAO;AAAA,IACL,CAAA,kBAAA,EAAc,MAAM,MAAM,CAAA,MAAA,CAAA;AAAA,IAC1B,wBAAA;AAAA,IACA,GAAG,KAAA,CAAM,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA;AAAA,IACpB,uBAAA;AAAA,IACA,GAAG,KAAA,CAAM,KAAA,CAAM,GAAG;AAAA,GACpB,CAAE,KAAK,IAAI,CAAA;AACb;AAKA,SAAS,eAAe,IAAA,EAAwB;AAC9C,EAAA,MAAM,UAAoB,EAAC;AAC3B,EAAA,MAAM,QAAA,GAAW;AAAA,IACf,+DAAA;AAAA,IACA,mCAAA;AAAA,IACA,iCAAA;AAAA,IACA;AAAA,GACF;AAEA,EAAA,QAAA,CAAS,OAAA,CAAQ,CAAC,OAAA,KAAY;AAC5B,IAAA,IAAI,KAAA;AACJ,IAAA,OAAA,CAAQ,KAAA,GAAQ,OAAA,CAAQ,IAAA,CAAK,IAAI,OAAO,IAAA,EAAM;AAC5C,MAAA,OAAA,CAAQ,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,IAAK,KAAA,CAAM,CAAC,CAAA,IAAK,KAAA,CAAM,CAAC,CAAA,IAAK,KAAA,CAAM,CAAC,CAAC,CAAA;AAAA,IAC3D;AAAA,EACF,CAAC,CAAA;AAED,EAAA,OAAO,CAAC,GAAG,IAAI,GAAA,CAAI,OAAO,CAAC,CAAA;AAC7B;AAKA,SAAS,eAAe,IAAA,EAAwB;AAC9C,EAAA,MAAMA,YAAoB,EAAC;AAC3B,EAAA,MAAM,QAAA,GAAW;AAAA,IACf,mEAAA;AAAA,IACA,2BAAA;AAAA,IACA;AAAA,GACF;AAEA,EAAA,QAAA,CAAS,OAAA,CAAQ,CAAC,OAAA,KAAY;AAC5B,IAAA,IAAI,KAAA;AACJ,IAAA,OAAA,CAAQ,KAAA,GAAQ,OAAA,CAAQ,IAAA,CAAK,IAAI,OAAO,IAAA,EAAM;AAC5C,MAAA,MAAM,KAAA,GAAA,CAAS,KAAA,CAAM,CAAC,CAAA,IAAK,EAAA,EAAI,KAAA,CAAM,GAAG,CAAA,CAAE,GAAA,CAAI,CAAC,CAAA,KAAM,CAAA,CAAE,MAAM,CAAA;AAC7D,MAAAA,SAAA,CAAQ,IAAA,CAAK,GAAG,KAAA,CAAM,MAAA,CAAO,OAAO,CAAC,CAAA;AAAA,IACvC;AAAA,EACF,CAAC,CAAA;AAED,EAAA,OAAO,CAAC,GAAG,IAAI,GAAA,CAAIA,SAAO,CAAC,CAAA;AAC7B;AAKA,SAAS,0BAA0B,IAAA,EAAwB;AACzD,EAAA,MAAM,YAAsB,EAAC;AAC7B,EAAA,MAAM,QAAA,GAAW;AAAA,IACf,gCAAA;AAAA,IACA,0CAAA;AAAA,IACA,0DAAA;AAAA,IACA,aAAA;AAAA,IACA;AAAA,GACF;AAEA,EAAA,QAAA,CAAS,OAAA,CAAQ,CAAC,OAAA,KAAY;AAC5B,IAAA,IAAI,KAAA;AACJ,IAAA,OAAA,CAAQ,KAAA,GAAQ,OAAA,CAAQ,IAAA,CAAK,IAAI,OAAO,IAAA,EAAM;AAC5C,MAAA,SAAA,CAAU,IAAA,CAAK,KAAA,CAAM,CAAC,CAAC,CAAA;AAAA,IACzB;AAAA,EACF,CAAC,CAAA;AAED,EAAA,OAAO,CAAC,GAAG,IAAI,GAAA,CAAI,SAAS,CAAC,CAAA;AAC/B;AAKA,SAAS,kBAAkB,IAAA,EAAwB;AACjD,EAAA,MAAM,UAAoB,EAAC;AAC3B,EAAA,MAAM,QAAA,GAAW;AAAA,IACf,gBAAA;AAAA,IACA,iBAAA;AAAA,IACA,oBAAA;AAAA,IACA;AAAA,GACF;AAEA,EAAA,QAAA,CAAS,OAAA,CAAQ,CAAC,OAAA,KAAY;AAC5B,IAAA,IAAI,KAAA;AACJ,IAAA,OAAA,CAAQ,KAAA,GAAQ,OAAA,CAAQ,IAAA,CAAK,IAAI,OAAO,IAAA,EAAM;AAC5C,MAAA,OAAA,CAAQ,IAAA,CAAK,KAAA,CAAM,CAAC,CAAC,CAAA;AAAA,IACvB;AAAA,EACF,CAAC,CAAA;AAED,EAAA,OAAO,CAAC,GAAG,IAAI,GAAA,CAAI,OAAO,CAAC,CAAA;AAC7B;AAKA,SAAS,qBAAqB,IAAA,EAAwB;AACpD,EAAA,MAAM,SAAmB,EAAC;AAC1B,EAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,IAAI,CAAA;AAE7B,EAAA,KAAA,CAAM,OAAA,CAAQ,CAAC,IAAA,KAAS;AACtB,IAAA,IACE,KAAK,QAAA,CAAS,MAAM,KACpB,IAAA,CAAK,QAAA,CAAS,OAAO,CAAA,IACrB,IAAA,CAAK,SAAS,MAAM,CAAA,IACpB,KAAK,QAAA,CAAS,KAAK,KACnB,IAAA,CAAK,QAAA,CAAS,KAAK,CAAA,EACnB;AACA,MAAA,MAAA,CAAO,KAAK,IAAA,CAAK,IAAA,GAAO,KAAA,CAAM,CAAA,EAAG,GAAG,CAAC,CAAA;AAAA,IACvC;AAAA,EACF,CAAC,CAAA;AAED,EAAA,OAAO,MAAA,CAAO,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA;AAC3B;AAKA,SAAS,iBAAiB,IAAA,EAAsB;AAC9C,EAAA,IAAI,IAAA,CAAK,UAAU,sBAAA,EAAwB;AACzC,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,OAAO,IAAA,CAAK,KAAA,CAAM,CAAA,EAAG,sBAAA,GAAyB,EAAE,CAAA,GAAI,oBAAA;AACtD;AAKO,SAAS,mBAAA,CACd,cACA,cAAA,EACwD;AACxD,EAAA,MAAM,QAAQ,YAAA,GAAe,cAAA;AAC7B,EAAA,MAAM,QAAQ,YAAA,GAAe,cAAA;AAC7B,EAAA,MAAM,YAAA,GAAA,CAAiB,KAAA,GAAQ,YAAA,GAAgB,GAAA,EAAK,QAAQ,CAAC,CAAA;AAE7D,EAAA,OAAO,EAAE,KAAA,EAAO,KAAA,EAAO,YAAA,EAAa;AACtC;;;ACtaO,IAAM,kBAAN,MAAyD;AAAA,EACtD,QAAA,uBAAe,GAAA,EAA6B;AAAA,EAEpD,SAAS,OAAA,EAAgC;AACvC,IAAA,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,OAAA,CAAQ,QAAA,EAAU,OAAO,CAAA;AAAA,EAC7C;AAAA,EAEA,QAAQ,QAAA,EAA0C;AAChD,IAAA,OAAO,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,QAAQ,CAAA,IAAK,IAAA;AAAA,EACxC;AAAA,EAEA,aAAA,GAA0B;AACxB,IAAA,OAAO,CAAC,GAAG,IAAA,CAAK,SAAS,IAAA,EAAM,EAAE,IAAA,EAAK;AAAA,EACxC;AACF,CAAA;;;ACgCO,SAAS,aAAA,GAAwB;AACtC,EAAA,OAAO,UAAA,EAAW;AACpB;;;AC9CA,IAAM,gBAAA,GAAmB,OAAA;AAElB,SAAS,cAAc,QAAA,EAAmC;AAC/D,EAAA,SAAS,eAAe,KAAA,EAAkB;AACxC,IAAA,OAAO;AAAA,MACL,mBAAmB,KAAA,CAAM,UAAA;AAAA,MACzB,eAAe,KAAA,CAAM,GAAA;AAAA,MACrB,KAAK,KAAA,CAAM;AAAA,KACb;AAAA,EACF;AAEA,EAAA,OAAO;AAAA,IACL,QAAA;AAAA,IACA,eAAA,EAAiB,gBAAA;AAAA,IAEjB,sBAAsB,KAAA,EAAqC;AACzD,MAAA,OAAO;AAAA,QACL,SAAS,aAAA,EAAc;AAAA,QACvB,SAAA,EAAW,eAAA;AAAA,QACX,QAAA;AAAA,QACA,eAAA,EAAiB,MAAM,gBAAA,IAAoB,gBAAA;AAAA,QAC3C,WAAW,KAAA,CAAM,UAAA;AAAA,QACjB,SAAA,EAAW,KAAK,GAAA,EAAI;AAAA,QACpB,cAAA,EAAgB,eAAe,KAAK,CAAA;AAAA,QACpC,OAAA,EAAS;AAAA,UACP,eAAe,KAAA,CAAM,eAAA;AAAA,UACrB,gBAAgB,KAAA,CAAM,eAAA;AAAA,UACtB,gBAAgB,KAAA,CAAM;AAAA;AACxB,OACF;AAAA,IACF,CAAA;AAAA,IAEA,yBAAyB,KAAA,EAA+C;AACtE,MAAA,IAAI,CAAC,KAAA,CAAM,SAAA,EAAW,OAAO,IAAA;AAC7B,MAAA,OAAO;AAAA,QACL,SAAS,aAAA,EAAc;AAAA,QACvB,SAAA,EAAW,kBAAA;AAAA,QACX,QAAA;AAAA,QACA,eAAA,EAAiB,MAAM,gBAAA,IAAoB,gBAAA;AAAA,QAC3C,WAAW,KAAA,CAAM,UAAA;AAAA,QACjB,SAAA,EAAW,KAAK,GAAA,EAAI;AAAA,QACpB,cAAA,EAAgB,eAAe,KAAK,CAAA;AAAA,QACpC,OAAA,EAAS;AAAA,UACP,UAAU,KAAA,CAAM,SAAA;AAAA,UAChB,WAAW,KAAA,CAAM,UAAA;AAAA,UACjB,cAAc,KAAA,CAAM;AAAA;AACtB,OACF;AAAA,IACF,CAAA;AAAA,IAEA,qBAAqB,KAAA,EAAoC;AACvD,MAAA,OAAO;AAAA,QACL,SAAS,aAAA,EAAc;AAAA,QACvB,SAAA,EAAW,cAAA;AAAA,QACX,QAAA;AAAA,QACA,eAAA,EAAiB,MAAM,gBAAA,IAAoB,gBAAA;AAAA,QAC3C,WAAW,KAAA,CAAM,UAAA;AAAA,QACjB,SAAA,EAAW,KAAK,GAAA,EAAI;AAAA,QACpB,cAAA,EAAgB,eAAe,KAAK,CAAA;AAAA,QACpC,OAAA,EAAS;AAAA,UACP,gBAAgB,KAAA,CAAM;AAAA;AACxB,OACF;AAAA,IACF;AAAA,GACF;AACF;;;ACxEO,IAAM,aAAA,GAAgB,cAAc,QAAQ,CAAA;;;ACA5C,IAAM,eAAA,GAAkB,cAAc,UAAU,CAAA;;;ACKhD,IAAM,gCAAA,GAAmC,CAAA;AAEhD,IAAM,cAAA,GAAiB,kCAAA;AAShB,SAAS,mBAAmB,OAAA,EAAgC;AACjE,EAAA,MAAM,KAAA,GAAQ,cAAA,CAAe,IAAA,CAAK,OAAA,CAAQ,MAAM,CAAA;AAChD,EAAA,IAAI,CAAC,KAAA,EAAO;AACV,IAAA,OAAO,IAAA;AAAA,EACT;AACA,EAAA,OAAO,MAAA,CAAO,KAAA,CAAM,CAAC,CAAC,CAAA;AACxB;AAEO,SAAS,8BAAA,CACd,OAAA,EACA,cAAA,GAAiB,gCAAA,EACS;AAC1B,EAAA,MAAM,YAAA,GAAe,mBAAmB,OAAO,CAAA;AAC/C,EAAA,IAAI,iBAAiB,IAAA,EAAM;AACzB,IAAA,OAAO;AAAA,MACL,UAAA,EAAY,KAAA;AAAA,MACZ,cAAA;AAAA,MACA,YAAA,EAAc,IAAA;AAAA,MACd,MAAA,EAAQ;AAAA,KACV;AAAA,EACF;AAEA,EAAA,IAAI,iBAAiB,cAAA,EAAgB;AACnC,IAAA,OAAO;AAAA,MACL,UAAA,EAAY,KAAA;AAAA,MACZ,cAAA;AAAA,MACA,YAAA;AAAA,MACA,MAAA,EAAQ;AAAA,KACV;AAAA,EACF;AAEA,EAAA,OAAO;AAAA,IACL,UAAA,EAAY,IAAA;AAAA,IACZ,cAAA;AAAA,IACA;AAAA,GACF;AACF;;;ACtDO,IAAM,yBAAA,GAA4B,EAAA;;;ACOzC,IAAM,MAAA,GAAS,EAAA,GAAK,EAAA,GAAK,EAAA,GAAK,GAAA;AAU9B,SAAS,mBAAmB,UAAA,EAAwD;AAClF,EAAA,IAAI,CAAC,UAAA,IAAc,UAAA,CAAW,MAAA,KAAW,CAAA,EAAG;AAC1C,IAAA,OAAO,MAAA;AAAA,EACT;AACA,EAAA,OAAO,CAAC,GAAG,IAAI,GAAA,CAAI,UAAU,CAAC,CAAA,CAAE,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA;AAC7C;AAKO,SAAS,yBAAyB,KAAA,EAAiD;AACxF,EAAA,MAAM,SAAA,GAAY,KAAA,CAAM,GAAA,IAAO,IAAA,CAAK,GAAA,EAAI;AACxC,EAAA,OAAO;AAAA,IACL,cAAc,UAAA,EAAW;AAAA,IACzB,SAAA;AAAA,IACA,UAAU,KAAA,CAAM,QAAA;AAAA,IAChB,WAAW,KAAA,CAAM,SAAA;AAAA,IACjB,UAAA,EAAY,kBAAA,CAAmB,KAAA,CAAM,UAAU,CAAA;AAAA,IAC/C,QAAA,EAAU,MAAM,QAAA,IAAY,SAAA;AAAA,IAC5B,QAAA,EAAU,IAAA;AAAA,IACV,aAAA,EAAe,yBAAA;AAAA,IACf,SAAA,EAAW,YAAa,yBAAA,GAA4B;AAAA,GACtD;AACF;AC1BO,SAAS,4BACd,OAAA,EACoB;AACpB,EAAA,IAAI,QAAQ,aAAA,EAAe;AACzB,IAAA,OAAOL,OAAAA,CAAQ,QAAQ,aAAa,CAAA;AAAA,EACtC;AACA,EAAA,IAAI,QAAQ,GAAA,EAAK;AACf,IAAA,OAAOA,OAAAA,CAAQ,QAAQ,GAAG,CAAA;AAAA,EAC5B;AACA,EAAA,OAAO,MAAA;AACT;AAEO,SAAS,0BACd,OAAA,EAC2B;AAC3B,EAAA,IAAI,QAAQ,iBAAA,IAAqB,OAAA,CAAQ,kBAAkB,IAAA,EAAK,CAAE,SAAS,CAAA,EAAG;AAC5E,IAAA,OAAO;AAAA,MACL,GAAA,EAAK,OAAA,CAAQ,iBAAA,CAAkB,IAAA,EAAK;AAAA,MACpC,MAAA,EAAQ,qBAAA;AAAA,MACR,aAAA,EAAe,4BAA4B,OAAO;AAAA,KACpD;AAAA,EACF;AAEA,EAAA,MAAM,aAAA,GAAgB,4BAA4B,OAAO,CAAA;AACzD,EAAA,IAAI,aAAA,EAAe;AACjB,IAAA,OAAO;AAAA,MACL,GAAA,EAAK,aAAA;AAAA,MACL,MAAA,EAAQ,gBAAA;AAAA,MACR;AAAA,KACF;AAAA,EACF;AAEA,EAAA,OAAO;AAAA,IACL,GAAA,EAAK,IAAA;AAAA,IACL,MAAA,EAAQ;AAAA,GACV;AACF;;;AClCA,SAAS,kBAAA,CACP,QAAA,EACA,SAAA,EACA,UAAA,EAC4B;AAI5B,EAAA,OAAO;AAAA,IACL,OAAA,EAAS,IAAA;AAAA,IACT,MAAA,EAAQ,SAAA;AAAA,IACR,YAAY,wBAAA,CAAyB;AAAA,MACnC,QAAA;AAAA,MACA,SAAA;AAAA,MACA,UAAA;AAAA,MACA,QAAA,EAAU;AAAA,KACX;AAAA,GACH;AACF;AAEO,SAAS,qBACd,KAAA,EAC4B;AAC5B,EAAA,MAAM,kBAAA,GAAqB,8BAAA;AAAA,IACzB,KAAA,CAAM,eAAA;AAAA,IACN;AAAA,GACF;AACA,EAAA,IAAI,CAAC,mBAAmB,UAAA,EAAY;AAClC,IAAA,OAAO,mBAAmB,KAAA,CAAM,QAAA,EAAU,6BAAA,EAA+B,CAAC,iBAAiB,CAAC,CAAA;AAAA,EAC9F;AAEA,EAAA,MAAM,QAAA,GAAW,yBAAA,CAA0B,KAAA,CAAM,cAAc,CAAA;AAC/D,EAAA,IAAI,CAAC,SAAS,GAAA,EAAK;AACjB,IAAA,OAAO,kBAAA,CAAmB,KAAA,CAAM,QAAA,EAAU,0BAAA,EAA4B;AAAA,MACpE,mBAAA;AAAA,MACA,eAAA;AAAA,MACA;AAAA,KACD,CAAA;AAAA,EACH;AAEA,EAAA,OAAO;AAAA,IACL,OAAA,EAAS,KAAA;AAAA,IACT,oBAAoB,QAAA,CAAS;AAAA,GAC/B;AACF;;;AC5CA,IAAI,eAAA,GAA0C,IAAA;AAEvC,SAAS,yBAAA,GAAqD;AACnE,EAAA,IAAI,CAAC,eAAA,EAAiB;AACpB,IAAA,eAAA,GAAkB,IAAI,eAAA,EAAgB;AACtC,IAAA,eAAA,CAAgB,SAAS,aAAa,CAAA;AACtC,IAAA,eAAA,CAAgB,SAAS,eAAe,CAAA;AAAA,EAC1C;AAEA,EAAA,OAAO,eAAA;AACT;ACCA,IAAM,cAAA,uBAAqB,GAAA,CAAI;AAAA,EAC7B,MAAA;AAAA,EACA,MAAA;AAAA,EACA,OAAA;AAAA,EACA,QAAA;AAAA,EACA,MAAA;AAAA,EACA,MAAA;AAAA,EACA,MAAA;AAAA,EACA,UAAA;AAAA,EACA,WAAA;AAAA,EACA,MAAA;AAAA,EACA;AACF,CAAC,CAAA;AAED,IAAM,iBAAA,GAAoB,EAAA;AAC1B,IAAM,eAAA,GAAkB,GAAA;AACxB,IAAM,oBAAA,uBAA2B,GAAA,CAAI,CAAC,QAAQ,OAAA,EAAS,QAAA,EAAU,cAAc,CAAC,CAAA;AAChF,IAAM,iBAAA,GAAoB,IAAA;AAE1B,IAAM,kBAAA,uBAAyB,GAAA,EAAoB;AAEnD,SAAS,iBAAA,CAAkB,UAAkB,SAAA,EAAwD;AACnG,EAAA,MAAM,QAAA,GAAW,YAAY,IAAA,CAAK,SAAA,CAAU,SAAS,CAAA,CAAE,KAAA,CAAM,CAAA,EAAG,GAAG,CAAA,GAAI,EAAA;AACvE,EAAA,OAAO,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,QAAQ,CAAA,CAAA;AAChC;AAEA,SAAS,YAAY,GAAA,EAAsB;AACzC,EAAA,MAAM,QAAA,GAAW,kBAAA,CAAmB,GAAA,CAAI,GAAG,CAAA;AAC3C,EAAA,IAAI,CAAC,UAAU,OAAO,KAAA;AACtB,EAAA,OAAO,IAAA,CAAK,GAAA,EAAI,GAAI,QAAA,GAAW,eAAA;AACjC;AAEA,SAAS,aAAa,GAAA,EAAmB;AACvC,EAAA,kBAAA,CAAmB,GAAA,CAAI,GAAA,EAAK,IAAA,CAAK,GAAA,EAAK,CAAA;AACtC,EAAA,IAAI,kBAAA,CAAmB,OAAO,GAAA,EAAK;AACjC,IAAA,MAAM,GAAA,GAAM,KAAK,GAAA,EAAI;AACrB,IAAA,KAAA,MAAW,CAAC,CAAA,EAAG,CAAC,CAAA,IAAK,kBAAA,CAAmB,SAAQ,EAAG;AACjD,MAAA,IAAI,GAAA,GAAM,CAAA,GAAI,eAAA,GAAkB,CAAA,EAAG;AACjC,QAAA,kBAAA,CAAmB,OAAO,CAAC,CAAA;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AACF;AAEA,SAAS,eAAA,CACP,QAAA,EACA,SAAA,EACA,UAAA,EACQ;AACR,EAAA,QAAQ,QAAA;AAAU,IAChB,KAAK,MAAA,EAAQ;AACX,MAAA,MAAM,IAAA,GAAQ,SAAA,EAAW,SAAA,IACtB,SAAA,EAAW,QAAA;AACd,MAAA,MAAM,WAAW,IAAA,EAAM,KAAA,CAAM,GAAG,CAAA,CAAE,KAAI,IAAK,MAAA;AAC3C,MAAA,MAAM,KAAA,GAAQ,UAAA,CAAW,KAAA,CAAM,IAAI,CAAA,CAAE,MAAA;AACrC,MAAA,OAAO,CAAA,KAAA,EAAQ,QAAQ,CAAA,EAAA,EAAK,KAAK,CAAA,OAAA,CAAA;AAAA,IACnC;AAAA,IACA,KAAK,MAAA;AAAA,IACL,KAAK,QAAA,EAAU;AACb,MAAA,MAAM,IAAA,GAAQ,SAAA,EAAW,SAAA,IACtB,SAAA,EAAW,QAAA;AACd,MAAA,MAAM,WAAW,IAAA,EAAM,KAAA,CAAM,GAAG,CAAA,CAAE,KAAI,IAAK,MAAA;AAC3C,MAAA,OAAO,UAAU,QAAQ,CAAA,CAAA;AAAA,IAC3B;AAAA,IACA,KAAK,OAAA,EAAS;AACZ,MAAA,MAAM,IAAA,GAAQ,SAAA,EAAW,SAAA,IACtB,SAAA,EAAW,QAAA;AACd,MAAA,MAAM,WAAW,IAAA,EAAM,KAAA,CAAM,GAAG,CAAA,CAAE,KAAI,IAAK,MAAA;AAC3C,MAAA,OAAO,WAAW,QAAQ,CAAA,CAAA;AAAA,IAC5B;AAAA,IACA,KAAK,MAAA,EAAQ;AACX,MAAA,MAAM,MAAM,SAAA,EAAW,OAAA;AACvB,MAAA,MAAM,QAAA,GAAW,GAAA,EAAK,KAAA,CAAM,IAAI,CAAA,CAAE,CAAC,CAAA,CAAE,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA,IAAK,SAAA;AACrD,MAAA,MAAM,QAAA,GAAW,UAAA,CAAW,WAAA,EAAY,CAAE,QAAA,CAAS,OAAO,CAAA,IAAK,UAAA,CAAW,WAAA,EAAY,CAAE,QAAA,CAAS,QAAQ,CAAA;AACzG,MAAA,OAAO,QAAA,GAAW,CAAA,gBAAA,EAAmB,QAAQ,CAAA,CAAA,GAAK,QAAQ,QAAQ,CAAA,CAAA;AAAA,IACpE;AAAA,IACA,KAAK,MAAA,EAAQ;AACX,MAAA,MAAM,UAAU,SAAA,EAAW,OAAA;AAC3B,MAAA,MAAM,UAAU,UAAA,CAAW,KAAA,CAAM,IAAI,CAAA,CAAE,MAAA,CAAO,OAAO,CAAA,CAAE,MAAA;AACvD,MAAA,OAAO,SAAS,OAAO,CAAA,cAAA,EAAiB,SAAS,KAAA,CAAM,CAAA,EAAG,EAAE,CAAC,CAAA,CAAA,CAAA;AAAA,IAC/D;AAAA,IACA,KAAK,MAAA,EAAQ;AACX,MAAA,MAAM,UAAU,SAAA,EAAW,OAAA;AAC3B,MAAA,MAAM,UAAU,UAAA,CAAW,KAAA,CAAM,IAAI,CAAA,CAAE,MAAA,CAAO,OAAO,CAAA,CAAE,MAAA;AACvD,MAAA,OAAO,SAAS,OAAO,CAAA,iBAAA,EAAoB,SAAS,KAAA,CAAM,CAAA,EAAG,EAAE,CAAC,CAAA,CAAA,CAAA;AAAA,IAClE;AAAA,IACA,KAAK,UAAA;AAAA,IACL,KAAK,WAAA,EAAa;AAChB,MAAA,MAAM,GAAA,GAAO,SAAA,EAAW,GAAA,IAA+B,SAAA,EAAW,KAAA;AAClE,MAAA,OAAO,CAAA,SAAA,EAAY,GAAA,EAAK,KAAA,CAAM,CAAA,EAAG,EAAE,CAAC,CAAA,CAAA;AAAA,IACtC;AAAA,IACA;AACE,MAAA,OAAO,GAAG,QAAQ,CAAA,UAAA,CAAA;AAAA;AAExB;AAEA,SAAS,eAAA,CACP,QAAA,EACA,SAAA,EACA,QAAA,EACA,kBAAA,EACyB;AACzB,EAAA,MAAM,QAAA,GAAoC;AAAA,IACxC,QAAA;AAAA,IACA;AAAA,GACF;AAEA,EAAA,IAAI,CAAC,WAAW,OAAO,QAAA;AAEvB,EAAA,QAAQ,QAAA;AAAU,IAChB,KAAK,MAAA;AAAA,IACL,KAAK,MAAA;AAAA,IACL,KAAK,OAAA;AAAA,IACL,KAAK,QAAA,EAAU;AACb,MAAA,MAAM,QAAA,GAAW,SAAA,CAAU,SAAA,IAAa,SAAA,CAAU,QAAA;AAClD,MAAA,IAAI,QAAA,EAAU;AACZ,QAAA,QAAA,CAAS,KAAA,GAAQ,CAAC,QAAQ,CAAA;AAAA,MAC5B;AACA,MAAA;AAAA,IACF;AAAA,IACA,KAAK,MAAA;AACH,MAAA,IAAI,UAAU,OAAA,EAAS;AACrB,QAAA,QAAA,CAAS,OAAA,GAAW,SAAA,CAAU,OAAA,CAAmB,KAAA,CAAM,GAAG,GAAG,CAAA;AAAA,MAC/D;AACA,MAAA;AAAA,IACF,KAAK,MAAA;AAAA,IACL,KAAK,MAAA;AACH,MAAA,IAAI,UAAU,OAAA,EAAS;AACrB,QAAA,QAAA,CAAS,UAAU,SAAA,CAAU,OAAA;AAAA,MAC/B;AACA,MAAA,IAAI,UAAU,IAAA,EAAM;AAClB,QAAA,QAAA,CAAS,aAAa,SAAA,CAAU,IAAA;AAAA,MAClC;AACA,MAAA;AAAA;AAGJ,EAAA,OAAO,QAAA;AACT;AAEA,eAAsB,kBAAA,GAAoC;AACxD,EAAA,IAAI;AACF,IAAA,MAAM,KAAA,GAAQ,MAAM,SAAA,EAAU;AAC9B,IAAA,MAAM,SAAA,GAAuB,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;AAE7C,IAAA,MAAM,QAAA,GAAW,eAAe,SAAS,CAAA;AACzC,IAAA,MAAM,OAAA,GAAU,yBAAA,EAA0B,CAAE,OAAA,CAAQ,QAAQ,CAAA;AAC5D,IAAA,IAAI,CAAC,OAAA,EAAS;AACZ,MAAA,KAAA,CAAM,CAAA,uCAAA,EAA0C,QAAQ,CAAA,CAAE,CAAA;AAC1D,MAAA,WAAA,CAAY,EAAE,QAAA,EAAU,IAAA,EAAM,CAAA;AAC9B,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,UAAA,GAAa,OAAA,CAAQ,wBAAA,CAAyB,SAAS,CAAA;AAC7D,IAAA,IAAI,CAAC,UAAA,EAAY;AACf,MAAA,WAAA,CAAY,EAAE,QAAA,EAAU,IAAA,EAAM,CAAA;AAC9B,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,cAAA,GAAiB,qBAAqB,UAAU,CAAA;AACtD,IAAA,IAAI,cAAA,CAAe,OAAA,IAAW,CAAC,cAAA,CAAe,kBAAA,EAAoB;AAChE,MAAA,KAAA,CAAM,CAAA,uCAAA,EAA0C,cAAA,CAAe,MAAM,CAAA,CAAE,CAAA;AACvE,MAAA,WAAA,CAAY,EAAE,QAAA,EAAU,IAAA,EAAM,CAAA;AAC9B,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,EAAE,QAAA,EAAU,SAAA,EAAW,YAAA,KAAiB,UAAA,CAAW,OAAA;AACzD,IAAA,IAAI,CAAC,QAAA,IAAY,CAAC,cAAA,CAAe,GAAA,CAAI,QAAQ,CAAA,EAAG;AAC9C,MAAA,WAAA,CAAY,EAAE,QAAA,EAAU,IAAA,EAAM,CAAA;AAC9B,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,QAAA,GAAW,iBAAA,CAAkB,QAAA,EAAU,SAAS,CAAA;AACtD,IAAA,IAAI,WAAA,CAAY,QAAQ,CAAA,EAAG;AACzB,MAAA,KAAA,CAAM,CAAA,gCAAA,EAAmC,QAAQ,CAAA,CAAE,CAAA;AACnD,MAAA,WAAA,CAAY,EAAE,QAAA,EAAU,IAAA,EAAM,CAAA;AAC9B,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,SAAA,GAAY,OAAO,YAAA,KAAiB,QAAA,GACtC,eACA,IAAA,CAAK,SAAA,CAAU,YAAA,EAAc,IAAA,EAAM,CAAC,CAAA;AAExC,IAAA,MAAM,aAAA,GAAgB,oBAAA,CAAqB,GAAA,CAAI,QAAQ,CAAA;AACvD,IAAA,IAAI,CAAC,aAAA,KAAkB,CAAC,SAAA,IAAa,SAAA,CAAU,SAAS,iBAAA,CAAA,EAAoB;AAC1E,MAAA,WAAA,CAAY,EAAE,QAAA,EAAU,IAAA,EAAM,CAAA;AAC9B,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,kBAAkB,SAAA,IAAa,EAAA;AACnC,IAAA,IAAI,aAAA,IAAiB,eAAA,CAAgB,MAAA,GAAS,iBAAA,EAAmB;AAC/D,MAAA,MAAM,QAAA,GACH,SAAA,EAAW,SAAA,IACX,SAAA,EAAW,QAAA,IACZ,cAAA;AACF,MAAA,MAAM,WAAW,QAAA,CAAS,KAAA,CAAM,GAAG,CAAA,CAAE,KAAI,IAAK,MAAA;AAC9C,MAAA,eAAA,GAAkB,kBAAkB,QAAQ;AAAA,MAAA,EAAW,QAAQ;AAAA,MAAA,EAAW,QAAQ,CAAA,CAAA;AAAA,IACpF;AAEA,IAAA,IACE,gBAAgB,QAAA,CAAS,mBAAmB,KAC5C,eAAA,CAAgB,QAAA,CAAS,uBAAuB,CAAA,EAChD;AACA,MAAA,WAAA,CAAY,EAAE,QAAA,EAAU,IAAA,EAAM,CAAA;AAC9B,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,EAAE,UAAA,EAAY,aAAA,EAAe,YAAA,EAAa,GAAI,kBAAA;AAAA,MAClD,QAAA;AAAA,MACA,SAAA;AAAA,MACA;AAAA,KACF;AAEA,IAAA,IAAI,aAAA,EAAe;AACjB,MAAA,MAAM,KAAA,GAAQ,mBAAA,CAAoB,YAAA,EAAc,UAAA,CAAW,MAAM,CAAA;AACjE,MAAA,KAAA,CAAM,CAAA,aAAA,EAAgB,MAAM,YAAY,CAAA,GAAA,EAAM,YAAY,CAAA,IAAA,EAAO,UAAA,CAAW,MAAM,CAAA,CAAA,CAAG,CAAA;AAAA,IACvF;AAEA,IAAA,MAAM,IAAA,GAAO,MAAM,OAAA,EAAQ;AAC3B,IAAA,MAAM,eAAA,GAAkB,uBAAA,CAAwB,QAAA,EAAU,UAAU,CAAA;AACpE,IAAA,MAAM,OAAA,GAAU,eAAA,CAAgB,QAAA,EAAU,SAAA,EAAW,eAAe,CAAA;AACpE,IAAA,MAAM,OAAA,GAAU,WAAW,MAAA,GAAS,iBAAA,GAChC,GAAG,UAAA,CAAW,KAAA,CAAM,CAAA,EAAG,iBAAiB,CAAC;AAAA,cAAA,EAAmB,aAAA,GAAgB,cAAA,GAAiB,EAAE,CAAA,CAAA,CAAA,GAC/F,UAAA;AAEJ,IAAA,MAAM,QAAA,GAAW,eAAA;AAAA,MACf,QAAA;AAAA,MACA,SAAA;AAAA,MACA,QAAA;AAAA,MACA,cAAA,CAAe;AAAA,KACjB;AAEA,IAAA,IAAI,aAAA,EAAe;AACjB,MAAA,QAAA,CAAS,UAAA,GAAa,IAAA;AACtB,MAAA,QAAA,CAAS,YAAA,GAAe,YAAA;AACxB,MAAA,QAAA,CAAS,iBAAiB,UAAA,CAAW,MAAA;AAAA,IACvC;AAEA,IAAA,MAAM,KAAK,QAAA,CAAS;AAAA,MAClB,IAAA,EAAM,eAAA;AAAA,MACN,OAAA;AAAA,MACA,OAAA;AAAA,MACA,IAAA,EAAM,QAAA;AAAA,MACN;AAAA,KACD,CAAA;AAED,IAAA,YAAA,CAAa,QAAQ,CAAA;AACrB,IAAA,WAAA,CAAY,EAAE,QAAA,EAAU,IAAA,EAAM,CAAA;AAAA,EAChC,SAAS,KAAA,EAAO;AACd,IAAA,KAAA,CAAM,CAAA,OAAA,EAAU,KAAK,CAAA,CAAE,CAAA;AACvB,IAAA,WAAA,CAAY,EAAE,QAAA,EAAU,IAAA,EAAM,CAAA;AAAA,EAChC;AACF;AAEA,IAAI,OAAA,CAAQ,IAAA,CAAK,CAAC,CAAA,IAAK,aAAA,CAAc,MAAA,CAAA,IAAA,CAAY,GAAG,CAAA,KAAM,OAAA,CAAQ,IAAA,CAAK,CAAC,CAAA,EAAG;AACzE,EAAA,KAAK,kBAAA,EAAmB;AAC1B","file":"post-tool-use.js","sourcesContent":["/**\n * Memvid Mind - Type Definitions\n *\n * Core types for Claude Code memory persistence.\n */\n\n/** Observation captured from tool use */\nexport interface Observation {\n  id: string;\n  timestamp: number;\n  type: ObservationType;\n  tool?: string;\n  summary: string;\n  content: string;\n  metadata?: ObservationMetadata;\n}\n\n/** Types of observations */\nexport type ObservationType =\n  | \"discovery\"      // New information discovered\n  | \"decision\"       // Decision made\n  | \"problem\"        // Problem identified\n  | \"solution\"       // Solution implemented\n  | \"pattern\"        // Pattern recognized\n  | \"warning\"        // Warning or concern\n  | \"success\"        // Successful outcome\n  | \"refactor\"       // Code refactored\n  | \"bugfix\"         // Bug fixed\n  | \"feature\";       // Feature added\n\n/** Metadata attached to observations */\nexport interface ObservationMetadata {\n  files?: string[];\n  functions?: string[];\n  error?: string;\n  confidence?: number;\n  tags?: string[];\n  sessionId?: string;\n  [key: string]: unknown;  // Allow additional properties\n}\n\n/** Session summary stored at end of session */\nexport interface SessionSummary {\n  id: string;\n  startTime: number;\n  endTime: number;\n  observationCount: number;\n  keyDecisions: string[];\n  filesModified: string[];\n  summary: string;\n}\n\n/** Context injected at session start */\nexport interface InjectedContext {\n  recentObservations: Observation[];\n  relevantMemories: Observation[];\n  sessionSummaries: SessionSummary[];\n  tokenCount: number;\n}\n\n/** Configuration for Memvid Mind */\nexport interface MindConfig {\n  /** Path to the .memvid file (default: .mind.mv2 in project root) */\n  memoryPath: string;\n  /** Maximum observations to inject at session start */\n  maxContextObservations: number;\n  /** Maximum tokens for context injection */\n  maxContextTokens: number;\n  /** Whether to auto-compress observations */\n  autoCompress: boolean;\n  /** Minimum confidence for storing observations */\n  minConfidence: number;\n  /** Enable debug logging */\n  debug: boolean;\n}\n\n/** Default configuration */\nexport const DEFAULT_CONFIG: MindConfig = {\n  memoryPath: \".claude/mind.mv2\",\n  maxContextObservations: 20,\n  maxContextTokens: 2000,\n  autoCompress: true,\n  minConfidence: 0.6,\n  debug: false,\n};\n\n/** Hook input from Claude Code */\nexport interface HookInput {\n  session_id: string;\n  platform?: string;\n  contract_version?: string;\n  project_id?: string;\n  transcript_path?: string;\n  cwd?: string;\n  hook_event_name?: string;\n  permission_mode?: string;\n  tool_name?: string;\n  tool_input?: Record<string, unknown>;\n  tool_response?: unknown; // Can be object or string depending on tool\n  tool_use_id?: string;\n}\n\n/** Hook output to Claude Code */\nexport interface HookOutput {\n  continue?: boolean;\n  result?: string;\n  decision?: \"block\" | \"approve\" | \"modify\";\n  reason?: string;\n  modified_input?: Record<string, unknown>;\n}\n\n/** Search result from memory */\nexport interface MemorySearchResult {\n  observation: Observation;\n  score: number;\n  snippet: string;\n}\n\n/** Statistics about the mind file */\nexport interface MindStats {\n  totalObservations: number;\n  totalSessions: number;\n  oldestMemory: number;\n  newestMemory: number;\n  fileSize: number;\n  topTypes: Record<ObservationType, number>;\n}\n","/**\n * Memvid Mind - Utility Helpers\n */\n\nimport { randomBytes } from \"node:crypto\";\n\n/**\n * Generate a unique ID\n */\nexport function generateId(): string {\n  return randomBytes(8).toString(\"hex\");\n}\n\n/**\n * Estimate token count for text (rough approximation)\n * ~4 characters per token for English text\n */\nexport function estimateTokens(text: string): number {\n  return Math.ceil(text.length / 4);\n}\n\n/**\n * Truncate text to fit within token limit\n */\nexport function truncateToTokens(text: string, maxTokens: number): string {\n  const maxChars = maxTokens * 4;\n  if (text.length <= maxChars) return text;\n  return text.slice(0, maxChars - 3) + \"...\";\n}\n\n/**\n * Format timestamp to human-readable string\n */\nexport function formatTimestamp(ts: number): string {\n  const date = new Date(ts);\n  const now = new Date();\n  const diffMs = now.getTime() - date.getTime();\n  const diffMins = Math.floor(diffMs / 60000);\n  const diffHours = Math.floor(diffMs / 3600000);\n  const diffDays = Math.floor(diffMs / 86400000);\n\n  if (diffMins < 1) return \"just now\";\n  if (diffMins < 60) return `${diffMins}m ago`;\n  if (diffHours < 24) return `${diffHours}h ago`;\n  if (diffDays < 7) return `${diffDays}d ago`;\n\n  return date.toLocaleDateString();\n}\n\n/**\n * Parse JSON safely\n */\nexport function safeJsonParse<T>(text: string, fallback: T): T {\n  try {\n    return JSON.parse(text) as T;\n  } catch {\n    return fallback;\n  }\n}\n\n/**\n * Read all stdin as string\n */\nexport async function readStdin(): Promise<string> {\n  const chunks: Buffer[] = [];\n\n  return new Promise((resolve, reject) => {\n    process.stdin.on(\"data\", (chunk) => chunks.push(chunk));\n    process.stdin.on(\"end\", () => resolve(Buffer.concat(chunks).toString(\"utf8\")));\n    process.stdin.on(\"error\", reject);\n  });\n}\n\n/**\n * Write JSON to stdout and exit immediately\n * (Prevents SDK background tasks from blocking process exit)\n */\nexport function writeOutput(output: unknown): never {\n  console.log(JSON.stringify(output));\n  process.exit(0);\n}\n\n/**\n * Log debug message to stderr\n */\nexport function debug(message: string): void {\n  if (process.env.MEMVID_MIND_DEBUG === \"1\") {\n    console.error(`[memvid-mind] ${message}`);\n  }\n}\n\n/**\n * Extract key information from tool output\n */\nexport function extractKeyInfo(toolName: string, output: string): string {\n  // Truncate very long outputs\n  const maxLength = 2000;\n  const truncated = output.length > maxLength\n    ? output.slice(0, maxLength) + \"\\n... (truncated)\"\n    : output;\n\n  // Tool-specific extraction\n  switch (toolName) {\n    case \"Read\":\n      // Extract file summary from read output\n      return extractFileReadSummary(truncated);\n    case \"Bash\":\n      // Extract command summary\n      return extractBashSummary(truncated);\n    case \"Edit\":\n      // Extract edit summary\n      return extractEditSummary(truncated);\n    case \"Grep\":\n    case \"Glob\":\n      // Extract search summary\n      return extractSearchSummary(truncated);\n    default:\n      return truncated;\n  }\n}\n\nfunction extractFileReadSummary(output: string): string {\n  const lines = output.split(\"\\n\");\n  if (lines.length <= 20) return output;\n  return `${lines.slice(0, 10).join(\"\\n\")}\\n... (${lines.length} lines total)`;\n}\n\nfunction extractBashSummary(output: string): string {\n  const lines = output.split(\"\\n\");\n  if (lines.length <= 30) return output;\n  return [\n    ...lines.slice(0, 10),\n    `... (${lines.length - 20} lines omitted)`,\n    ...lines.slice(-10),\n  ].join(\"\\n\");\n}\n\nfunction extractEditSummary(output: string): string {\n  // Edits are usually compact, return as-is\n  return output;\n}\n\nfunction extractSearchSummary(output: string): string {\n  const lines = output.split(\"\\n\").filter(Boolean);\n  if (lines.length <= 20) return output;\n  return [\n    ...lines.slice(0, 15),\n    `... and ${lines.length - 15} more results`,\n  ].join(\"\\n\");\n}\n\n/**\n * Classify observation type from tool and output\n */\nexport function classifyObservationType(\n  toolName: string,\n  output: string\n): \"discovery\" | \"decision\" | \"problem\" | \"solution\" | \"pattern\" | \"warning\" | \"success\" | \"refactor\" | \"bugfix\" | \"feature\" {\n  const lowerOutput = output.toLowerCase();\n\n  // Error detection\n  if (\n    lowerOutput.includes(\"error\") ||\n    lowerOutput.includes(\"failed\") ||\n    lowerOutput.includes(\"exception\")\n  ) {\n    return \"problem\";\n  }\n\n  // Success detection\n  if (\n    lowerOutput.includes(\"success\") ||\n    lowerOutput.includes(\"passed\") ||\n    lowerOutput.includes(\"completed\")\n  ) {\n    return \"success\";\n  }\n\n  // Warning detection\n  if (lowerOutput.includes(\"warning\") || lowerOutput.includes(\"deprecated\")) {\n    return \"warning\";\n  }\n\n  // Tool-based classification\n  switch (toolName) {\n    case \"Read\":\n    case \"Glob\":\n    case \"Grep\":\n      return \"discovery\";\n    case \"Edit\":\n      if (lowerOutput.includes(\"fix\") || lowerOutput.includes(\"bug\")) {\n        return \"bugfix\";\n      }\n      return \"refactor\";\n    case \"Write\":\n      return \"feature\";\n    default:\n      return \"discovery\";\n  }\n}\n","import lockfile from \"proper-lockfile\";\nimport { mkdir, open } from \"node:fs/promises\";\nimport { dirname } from \"node:path\";\n\nconst LOCK_OPTIONS = {\n  stale: 30000,\n  retries: {\n    retries: 1000,\n    minTimeout: 5,\n    maxTimeout: 50,\n  },\n} as const;\n\nexport async function withMemvidLock<T>(\n  lockPath: string,\n  fn: () => Promise<T>\n): Promise<T> {\n  await mkdir(dirname(lockPath), { recursive: true });\n  const handle = await open(lockPath, \"a\");\n  await handle.close();\n\n  const release = await lockfile.lock(lockPath, LOCK_OPTIONS);\n  try {\n    return await fn();\n  } finally {\n    await release();\n  }\n}\n","import { resolve } from \"node:path\";\n\nexport type MemoryPathMode = \"legacy_first\" | \"platform_opt_in\";\n\nexport interface MemoryPathPolicyInput {\n  projectDir: string;\n  platform: string;\n  legacyRelativePath: string;\n  platformRelativePath?: string;\n  platformOptIn?: boolean;\n}\n\nexport interface MemoryPathPolicyResult {\n  mode: MemoryPathMode;\n  memoryPath: string;\n}\n\nfunction defaultPlatformRelativePath(platform: string): string {\n  return `.claude/mind-${platform}.mv2`;\n}\n\nexport function resolveMemoryPathPolicy(input: MemoryPathPolicyInput): MemoryPathPolicyResult {\n  if (input.platformOptIn) {\n    const relative = input.platformRelativePath || defaultPlatformRelativePath(input.platform);\n    return {\n      mode: \"platform_opt_in\",\n      memoryPath: resolve(input.projectDir, relative),\n    };\n  }\n\n  return {\n    mode: \"legacy_first\",\n    memoryPath: resolve(input.projectDir, input.legacyRelativePath),\n  };\n}\n","import type { HookInput } from \"../types.js\";\n\nfunction normalizePlatform(value: string | undefined): string | undefined {\n  if (!value) return undefined;\n  const normalized = value.trim().toLowerCase();\n  return normalized.length > 0 ? normalized : undefined;\n}\n\nexport function detectPlatformFromEnv(): string {\n  const explicitFromEnv = normalizePlatform(process.env.MEMVID_PLATFORM);\n  if (explicitFromEnv) {\n    return explicitFromEnv;\n  }\n\n  if (process.env.OPENCODE === \"1\" || process.env.OPENCODE_SESSION === \"1\") {\n    return \"opencode\";\n  }\n\n  return \"claude\";\n}\n\nexport function detectPlatform(input: HookInput): string {\n  const explicitFromHook = normalizePlatform(input.platform);\n  if (explicitFromHook) {\n    return explicitFromHook;\n  }\n\n  return detectPlatformFromEnv();\n}\n","/**\n * Memvid Mind - Core Engine\n *\n * The brain behind Claude's persistent memory.\n * Stores everything in ONE portable .memvid file.\n */\n\n// Use dynamic import to allow smart-install to run first\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Memvid = any;\n\nimport { existsSync, readdirSync, unlinkSync } from \"node:fs\";\nimport { resolve, dirname } from \"node:path\";\nimport { mkdir } from \"node:fs/promises\";\nimport {\n  type Observation,\n  type ObservationType,\n  type SessionSummary,\n  type InjectedContext,\n  type MindConfig,\n  type MindStats,\n  type MemorySearchResult,\n  DEFAULT_CONFIG,\n} from \"../types.js\";\nimport { generateId, estimateTokens } from \"../utils/helpers.js\";\nimport { withMemvidLock } from \"../utils/memvid-lock.js\";\nimport { resolveMemoryPathPolicy } from \"../platforms/path-policy.js\";\nimport { detectPlatformFromEnv } from \"../platforms/platform-detector.js\";\n\n/**\n * Prune old backup files, keeping only the most recent N\n */\nfunction pruneBackups(memoryPath: string, keepCount: number): void {\n  try {\n    const dir = dirname(memoryPath);\n    const baseName = memoryPath.split(\"/\").pop() || \"mind.mv2\";\n    const backupPattern = new RegExp(`^${baseName.replace(\".\", \"\\\\.\")}\\\\.backup-\\\\d+$`);\n\n    const files = readdirSync(dir);\n    const backups = files\n      .filter(f => backupPattern.test(f))\n      .map(f => ({\n        name: f,\n        path: resolve(dir, f),\n        time: parseInt(f.split(\"-\").pop() || \"0\", 10),\n      }))\n      .sort((a, b) => b.time - a.time); // newest first\n\n    // Delete old backups beyond keepCount\n    for (let i = keepCount; i < backups.length; i++) {\n      try {\n        unlinkSync(backups[i].path);\n        console.error(`[memvid-mind] Pruned old backup: ${backups[i].name}`);\n      } catch {\n        // Ignore errors deleting backups\n      }\n    }\n  } catch {\n    // Ignore errors during pruning\n  }\n}\n\n// Lazy-loaded SDK functions\nlet sdkLoaded = false;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet use: any;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet create: any;\n\nasync function loadSDK(): Promise<void> {\n  if (sdkLoaded) return;\n  const sdk = await import(\"@memvid/sdk\");\n  use = sdk.use;\n  create = sdk.create;\n  sdkLoaded = true;\n}\n\n/**\n * Mind - Claude's portable memory engine\n *\n * @example\n * ```typescript\n * const mind = await Mind.open();\n * await mind.remember({\n *   type: \"decision\",\n *   summary: \"Chose React over Vue for frontend\",\n *   content: \"Decision rationale: team familiarity, ecosystem...\"\n * });\n *\n * const context = await mind.getContext(\"authentication\");\n * ```\n */\nexport class Mind {\n  private memvid: Memvid;\n  private config: MindConfig;\n  private memoryPath: string;\n  private sessionId: string;\n  private initialized = false;\n\n  private constructor(memvid: Memvid, config: MindConfig, memoryPath: string) {\n    this.memvid = memvid;\n    this.config = config;\n    this.memoryPath = memoryPath;\n    this.sessionId = generateId();\n  }\n\n  /**\n   * Open or create a Mind instance\n   */\n  static async open(configOverrides: Partial<MindConfig> = {}): Promise<Mind> {\n    // Load SDK dynamically (allows smart-install to run first)\n    await loadSDK();\n\n    const config = { ...DEFAULT_CONFIG, ...configOverrides };\n\n    // Resolve path relative to project dir (use CLAUDE_PROJECT_DIR if available)\n    const projectDir = process.env.CLAUDE_PROJECT_DIR || process.cwd();\n    const platform = detectPlatformFromEnv();\n    const optIn = process.env.MEMVID_PLATFORM_PATH_OPT_IN === \"1\";\n    const pathPolicy = resolveMemoryPathPolicy({\n      projectDir,\n      platform,\n      legacyRelativePath: config.memoryPath,\n      platformRelativePath: process.env.MEMVID_PLATFORM_MEMORY_PATH,\n      platformOptIn: optIn,\n    });\n    const memoryPath = pathPolicy.memoryPath;\n    const memoryDir = dirname(memoryPath);\n\n    // Ensure directory exists\n    await mkdir(memoryDir, { recursive: true });\n\n    // Open or create the memvid file\n    let memvid: Memvid;\n    const MAX_FILE_SIZE_MB = 100; // Files over 100MB are likely corrupted\n    const lockPath = `${memoryPath}.lock`;\n\n    await withMemvidLock(lockPath, async () => {\n      if (!existsSync(memoryPath)) {\n        memvid = await create(memoryPath, \"basic\");\n        return;\n      }\n\n      // Check file size - very large files are likely corrupted and will hang\n      const { statSync, renameSync, unlinkSync } = await import(\"node:fs\");\n      const fileSize = statSync(memoryPath).size;\n      const fileSizeMB = fileSize / (1024 * 1024);\n\n      if (fileSizeMB > MAX_FILE_SIZE_MB) {\n        console.error(`[memvid-mind] Memory file too large (${fileSizeMB.toFixed(1)}MB), likely corrupted. Creating fresh memory...`);\n        const backupPath = `${memoryPath}.backup-${Date.now()}`;\n        try { renameSync(memoryPath, backupPath); } catch { /* ignore */ }\n        memvid = await create(memoryPath, \"basic\");\n        return;\n      }\n\n      try {\n        memvid = await use(\"basic\", memoryPath);\n      } catch (openError: unknown) {\n        const errorMessage = openError instanceof Error ? openError.message : String(openError);\n        // Handle corrupted or incompatible memory files\n        if (errorMessage.includes(\"Deserialization\") ||\n            errorMessage.includes(\"UnexpectedVariant\") ||\n            errorMessage.includes(\"Invalid\") ||\n            errorMessage.includes(\"corrupt\") ||\n            errorMessage.includes(\"validation failed\") ||\n            errorMessage.includes(\"unable to recover\") ||\n            errorMessage.includes(\"table of contents\")) {\n          console.error(\"[memvid-mind] Memory file corrupted, creating fresh memory...\");\n          const backupPath = `${memoryPath}.backup-${Date.now()}`;\n          try {\n            renameSync(memoryPath, backupPath);\n          } catch {\n            try { unlinkSync(memoryPath); } catch { /* ignore */ }\n          }\n          memvid = await create(memoryPath, \"basic\");\n          return;\n        }\n        throw openError;\n      }\n    });\n\n    const mind = new Mind(memvid, config, memoryPath);\n    mind.initialized = true;\n\n    // Prune old backups (keep only most recent 3)\n    pruneBackups(memoryPath, 3);\n\n    if (config.debug) {\n      console.error(`[memvid-mind] Opened: ${memoryPath}`);\n    }\n\n    return mind;\n  }\n\n  private async withLock<T>(fn: () => Promise<T>): Promise<T> {\n    const memoryPath = this.getMemoryPath();\n    const lockPath = `${memoryPath}.lock`;\n    return withMemvidLock(lockPath, fn);\n  }\n\n  /**\n   * Remember an observation\n   */\n  async remember(input: {\n    type: ObservationType;\n    summary: string;\n    content: string;\n    tool?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<string> {\n    const observation: Observation = {\n      id: generateId(),\n      timestamp: Date.now(),\n      type: input.type,\n      tool: input.tool,\n      summary: input.summary,\n      content: input.content,\n      metadata: {\n        ...input.metadata,\n        sessionId: this.sessionId,\n      },\n    };\n\n    const frameId = await this.withLock(async () => {\n      return this.memvid.put({\n        title: `[${observation.type}] ${observation.summary}`,\n        label: observation.type,\n        text: observation.content,\n        metadata: {\n          observationId: observation.id,\n          timestamp: observation.timestamp,\n          tool: observation.tool,\n          sessionId: this.sessionId,\n          ...observation.metadata,\n        },\n        tags: [observation.type, observation.tool].filter(Boolean) as string[],\n      });\n    });\n\n    if (this.config.debug) {\n      console.error(`[memvid-mind] Remembered: ${observation.summary}`);\n    }\n\n    return frameId;\n  }\n\n  /**\n   * Search memories by query (uses fast lexical search)\n   */\n  async search(query: string, limit = 10): Promise<MemorySearchResult[]> {\n    return this.withLock(async () => {\n      return this.searchUnlocked(query, limit);\n    });\n  }\n\n  private async searchUnlocked(query: string, limit: number): Promise<MemorySearchResult[]> {\n    const results = await this.memvid.find(query, { k: limit, mode: \"lex\" });\n\n    return (results.frames || []).map((frame: any) => ({\n      observation: {\n        id: frame.metadata?.observationId || frame.frame_id,\n        timestamp: frame.metadata?.timestamp || 0,\n        type: frame.label as ObservationType,\n        tool: frame.metadata?.tool,\n        summary: frame.title?.replace(/^\\[.*?\\]\\s*/, \"\") || \"\",\n        content: frame.text || \"\",\n        metadata: frame.metadata,\n      },\n      score: frame.score || 0,\n      snippet: frame.snippet || frame.text?.slice(0, 200) || \"\",\n    }));\n  }\n\n  /**\n   * Ask the memory a question (uses fast lexical search)\n   */\n  async ask(question: string): Promise<string> {\n    return this.withLock(async () => {\n      const result = await this.memvid.ask(question, { k: 5, mode: \"lex\" });\n      return result.answer || \"No relevant memories found.\";\n    });\n  }\n\n  /**\n   * Get context for session start\n   */\n  async getContext(query?: string): Promise<InjectedContext> {\n    return this.withLock(async () => {\n      // Get recent observations via timeline\n      const timeline = await this.memvid.timeline({\n        limit: this.config.maxContextObservations,\n        reverse: true,\n      });\n\n      // SDK returns array directly or { frames: [...] }\n      const frames = Array.isArray(timeline) ? timeline : (timeline.frames || []);\n\n      const recentObservations: Observation[] = frames.map(\n        (frame: any) => {\n          // Get timestamp - SDK returns seconds, convert to milliseconds if needed\n          let ts = frame.metadata?.timestamp || frame.timestamp || 0;\n          // If timestamp looks like seconds (before year 2100 in seconds), convert to ms\n          if (ts > 0 && ts < 4102444800) {\n            ts = ts * 1000;\n          }\n          return {\n            id: frame.metadata?.observationId || frame.frame_id,\n            timestamp: ts,\n            type: (frame.label || frame.metadata?.type || \"observation\") as ObservationType,\n            tool: frame.metadata?.tool,\n            summary: frame.title?.replace(/^\\[.*?\\]\\s*/, \"\") || frame.preview?.slice(0, 100) || \"\",\n            content: frame.text || frame.preview || \"\",\n            metadata: frame.metadata,\n          };\n        }\n      );\n\n      // Get relevant memories if query provided\n      let relevantMemories: Observation[] = [];\n      if (query) {\n        const searchResults = await this.searchUnlocked(query, 10);\n        relevantMemories = searchResults.map((r) => r.observation);\n      }\n\n      // Build context with token limit\n      const contextParts: string[] = [];\n      let tokenCount = 0;\n\n      // Add recent observations\n      for (const obs of recentObservations) {\n        const text = `[${obs.type}] ${obs.summary}`;\n        const tokens = estimateTokens(text);\n        if (tokenCount + tokens > this.config.maxContextTokens) break;\n        contextParts.push(text);\n        tokenCount += tokens;\n      }\n\n      return {\n        recentObservations,\n        relevantMemories,\n        sessionSummaries: [], // TODO: Implement session summaries\n        tokenCount,\n      };\n    });\n  }\n\n  /**\n   * Save a session summary\n   */\n  async saveSessionSummary(summary: {\n    keyDecisions: string[];\n    filesModified: string[];\n    summary: string;\n  }): Promise<string> {\n    const sessionSummary: SessionSummary = {\n      id: this.sessionId,\n      startTime: Date.now() - 3600000, // Approximate\n      endTime: Date.now(),\n      observationCount: 0, // TODO: Track this\n      keyDecisions: summary.keyDecisions,\n      filesModified: summary.filesModified,\n      summary: summary.summary,\n    };\n\n    return this.withLock(async () => {\n      return this.memvid.put({\n        title: `Session Summary: ${new Date().toISOString().split(\"T\")[0]}`,\n        label: \"session\",\n        text: JSON.stringify(sessionSummary, null, 2),\n        metadata: sessionSummary as unknown as Record<string, unknown>,\n        tags: [\"session\", \"summary\"],\n      });\n    });\n  }\n\n  /**\n   * Get memory statistics\n   */\n  async stats(): Promise<MindStats> {\n    return this.withLock(async () => {\n      const stats = await this.memvid.stats();\n      const timeline = await this.memvid.timeline({ limit: 1, reverse: false });\n      const recentTimeline = await this.memvid.timeline({ limit: 1, reverse: true });\n\n      // SDK returns array directly or { frames: [...] }\n      const oldestFrames = Array.isArray(timeline) ? timeline : (timeline.frames || []);\n      const newestFrames = Array.isArray(recentTimeline) ? recentTimeline : (recentTimeline.frames || []);\n\n      return {\n        totalObservations: (stats.frame_count as number) || 0,\n        totalSessions: 0, // TODO: Count unique sessions\n        oldestMemory: (oldestFrames[0] as any)?.metadata?.timestamp || (oldestFrames[0] as any)?.timestamp || 0,\n        newestMemory: (newestFrames[0] as any)?.metadata?.timestamp || (newestFrames[0] as any)?.timestamp || 0,\n        fileSize: (stats.size_bytes as number) || 0,\n        topTypes: {} as Record<ObservationType, number>, // TODO: Aggregate\n      };\n    });\n  }\n\n  /**\n   * Get the session ID\n   */\n  getSessionId(): string {\n    return this.sessionId;\n  }\n\n  /**\n   * Get the memory file path\n   */\n  getMemoryPath(): string {\n    return this.memoryPath;\n  }\n\n  /**\n   * Check if initialized\n   */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n}\n\n// Singleton instance for hooks\nlet mindInstance: Mind | null = null;\n\n/**\n * Get or create the Mind singleton\n */\nexport async function getMind(config?: Partial<MindConfig>): Promise<Mind> {\n  if (!mindInstance) {\n    mindInstance = await Mind.open(config);\n  }\n  return mindInstance;\n}\n\n/**\n * Reset the Mind singleton (for testing)\n */\nexport function resetMind(): void {\n  mindInstance = null;\n}\n","/**\n * Memvid Mind - Endless Mode Compression\n *\n * Compresses large tool outputs to ~500 tokens while preserving key information.\n * This enables 20x more tool uses before hitting context limits.\n */\n\n// Target compressed size in characters (~500 tokens  2000 chars)\nconst TARGET_COMPRESSED_SIZE = 2000;\n\n// Threshold for when to apply compression\nconst COMPRESSION_THRESHOLD = 3000;\n\n/**\n * Compress tool output while preserving key information\n */\nexport function compressToolOutput(\n  toolName: string,\n  toolInput: Record<string, unknown> | undefined,\n  output: string\n): { compressed: string; wasCompressed: boolean; originalSize: number } {\n  const originalSize = output.length;\n\n  // Don't compress small outputs\n  if (originalSize <= COMPRESSION_THRESHOLD) {\n    return { compressed: output, wasCompressed: false, originalSize };\n  }\n\n  let compressed: string;\n\n  switch (toolName) {\n    case \"Read\":\n      compressed = compressFileRead(toolInput, output);\n      break;\n    case \"Bash\":\n      compressed = compressBashOutput(toolInput, output);\n      break;\n    case \"Grep\":\n      compressed = compressGrepOutput(toolInput, output);\n      break;\n    case \"Glob\":\n      compressed = compressGlobOutput(toolInput, output);\n      break;\n    case \"Edit\":\n    case \"Write\":\n      compressed = compressEditOutput(toolInput, output);\n      break;\n    default:\n      compressed = compressGeneric(output);\n  }\n\n  return {\n    compressed: truncateToTarget(compressed),\n    wasCompressed: true,\n    originalSize,\n  };\n}\n\n/**\n * Compress file read output - extract structure and key patterns\n */\nfunction compressFileRead(\n  toolInput: Record<string, unknown> | undefined,\n  output: string\n): string {\n  const filePath = (toolInput?.file_path as string) || \"unknown\";\n  const fileName = filePath.split(\"/\").pop() || \"file\";\n  const lines = output.split(\"\\n\");\n  const totalLines = lines.length;\n\n  // Extract key information\n  const imports = extractImports(output);\n  const exports = extractExports(output);\n  const functions = extractFunctionSignatures(output);\n  const classes = extractClassNames(output);\n  const errors = extractErrorPatterns(output);\n\n  const parts: string[] = [\n    ` File: ${fileName} (${totalLines} lines)`,\n  ];\n\n  if (imports.length > 0) {\n    parts.push(`\\n Imports: ${imports.slice(0, 10).join(\", \")}${imports.length > 10 ? ` (+${imports.length - 10} more)` : \"\"}`);\n  }\n\n  if (exports.length > 0) {\n    parts.push(`\\n Exports: ${exports.slice(0, 10).join(\", \")}${exports.length > 10 ? ` (+${exports.length - 10} more)` : \"\"}`);\n  }\n\n  if (functions.length > 0) {\n    parts.push(`\\n Functions: ${functions.slice(0, 10).join(\", \")}${functions.length > 10 ? ` (+${functions.length - 10} more)` : \"\"}`);\n  }\n\n  if (classes.length > 0) {\n    parts.push(`\\n Classes: ${classes.join(\", \")}`);\n  }\n\n  if (errors.length > 0) {\n    parts.push(`\\n Errors/TODOs: ${errors.slice(0, 5).join(\"; \")}`);\n  }\n\n  // Add first and last few lines for context\n  const contextLines = [\n    \"\\n--- First 10 lines ---\",\n    ...lines.slice(0, 10),\n    \"\\n--- Last 5 lines ---\",\n    ...lines.slice(-5),\n  ];\n\n  parts.push(contextLines.join(\"\\n\"));\n\n  return parts.join(\"\");\n}\n\n/**\n * Compress bash output - focus on errors and key results\n */\nfunction compressBashOutput(\n  toolInput: Record<string, unknown> | undefined,\n  output: string\n): string {\n  const command = (toolInput?.command as string) || \"command\";\n  const shortCmd = command.split(\"\\n\")[0].slice(0, 100);\n  const lines = output.split(\"\\n\");\n\n  // Check for errors\n  const errorLines = lines.filter(\n    (l) =>\n      l.toLowerCase().includes(\"error\") ||\n      l.toLowerCase().includes(\"failed\") ||\n      l.toLowerCase().includes(\"exception\") ||\n      l.toLowerCase().includes(\"warning\")\n  );\n\n  // Check for success indicators\n  const successLines = lines.filter(\n    (l) =>\n      l.toLowerCase().includes(\"success\") ||\n      l.toLowerCase().includes(\"passed\") ||\n      l.toLowerCase().includes(\"completed\") ||\n      l.toLowerCase().includes(\"done\")\n  );\n\n  const parts: string[] = [` Command: ${shortCmd}`];\n\n  if (errorLines.length > 0) {\n    parts.push(`\\n Errors (${errorLines.length}):`);\n    parts.push(errorLines.slice(0, 10).join(\"\\n\"));\n  }\n\n  if (successLines.length > 0) {\n    parts.push(`\\n Success indicators:`);\n    parts.push(successLines.slice(0, 5).join(\"\\n\"));\n  }\n\n  // Add summary stats\n  parts.push(`\\n Output: ${lines.length} lines total`);\n\n  // Add first and last lines\n  if (lines.length > 20) {\n    parts.push(\"\\n--- First 10 lines ---\");\n    parts.push(lines.slice(0, 10).join(\"\\n\"));\n    parts.push(\"\\n--- Last 5 lines ---\");\n    parts.push(lines.slice(-5).join(\"\\n\"));\n  } else {\n    parts.push(\"\\n--- Full output ---\");\n    parts.push(lines.join(\"\\n\"));\n  }\n\n  return parts.join(\"\");\n}\n\n/**\n * Compress grep output - summarize matches\n */\nfunction compressGrepOutput(\n  toolInput: Record<string, unknown> | undefined,\n  output: string\n): string {\n  const pattern = (toolInput?.pattern as string) || \"pattern\";\n  const lines = output.split(\"\\n\").filter(Boolean);\n\n  // Extract unique files\n  const files = new Set<string>();\n  lines.forEach((line) => {\n    const match = line.match(/^([^:]+):/);\n    if (match) files.add(match[1]);\n  });\n\n  const parts: string[] = [\n    ` Grep: \"${pattern.slice(0, 50)}\"`,\n    ` Found in ${files.size} files, ${lines.length} matches`,\n  ];\n\n  if (files.size > 0) {\n    parts.push(`\\n Files: ${Array.from(files).slice(0, 15).join(\", \")}${files.size > 15 ? ` (+${files.size - 15} more)` : \"\"}`);\n  }\n\n  // Show first 10 matches\n  parts.push(\"\\n--- Top matches ---\");\n  parts.push(lines.slice(0, 10).join(\"\\n\"));\n\n  if (lines.length > 10) {\n    parts.push(`\\n... and ${lines.length - 10} more matches`);\n  }\n\n  return parts.join(\"\");\n}\n\n/**\n * Compress glob output - summarize file list\n */\nfunction compressGlobOutput(\n  toolInput: Record<string, unknown> | undefined,\n  output: string\n): string {\n  const pattern = (toolInput?.pattern as string) || \"pattern\";\n\n  // Try to parse as JSON (Glob returns JSON)\n  let files: string[] = [];\n  try {\n    const parsed = JSON.parse(output);\n    files = parsed.filenames || [];\n  } catch {\n    files = output.split(\"\\n\").filter(Boolean);\n  }\n\n  // Group by directory\n  const byDir: Record<string, string[]> = {};\n  files.forEach((f) => {\n    const dir = f.split(\"/\").slice(0, -1).join(\"/\") || \"/\";\n    const file = f.split(\"/\").pop() || f;\n    if (!byDir[dir]) byDir[dir] = [];\n    byDir[dir].push(file);\n  });\n\n  const parts: string[] = [\n    ` Glob: \"${pattern.slice(0, 50)}\"`,\n    ` Found ${files.length} files in ${Object.keys(byDir).length} directories`,\n  ];\n\n  // Show top directories\n  const topDirs = Object.entries(byDir)\n    .sort((a, b) => b[1].length - a[1].length)\n    .slice(0, 5);\n\n  parts.push(\"\\n--- Top directories ---\");\n  topDirs.forEach(([dir, dirFiles]) => {\n    const shortDir = dir.split(\"/\").slice(-3).join(\"/\");\n    parts.push(`${shortDir}/ (${dirFiles.length} files)`);\n  });\n\n  // Show some file names\n  parts.push(\"\\n--- Sample files ---\");\n  parts.push(files.slice(0, 15).map((f) => f.split(\"/\").pop()).join(\", \"));\n\n  return parts.join(\"\");\n}\n\n/**\n * Compress edit output\n */\nfunction compressEditOutput(\n  toolInput: Record<string, unknown> | undefined,\n  output: string\n): string {\n  const filePath = (toolInput?.file_path as string) || \"unknown\";\n  const fileName = filePath.split(\"/\").pop() || \"file\";\n\n  return [\n    ` Edited: ${fileName}`,\n    ` Changes applied successfully`,\n    output.slice(0, 500),\n  ].join(\"\\n\");\n}\n\n/**\n * Generic compression for unknown tool types\n */\nfunction compressGeneric(output: string): string {\n  const lines = output.split(\"\\n\");\n\n  if (lines.length <= 30) {\n    return output;\n  }\n\n  return [\n    ` Output: ${lines.length} lines`,\n    \"--- First 15 lines ---\",\n    ...lines.slice(0, 15),\n    \"--- Last 10 lines ---\",\n    ...lines.slice(-10),\n  ].join(\"\\n\");\n}\n\n/**\n * Extract import statements\n */\nfunction extractImports(code: string): string[] {\n  const imports: string[] = [];\n  const patterns = [\n    /import\\s+(?:{\\s*([^}]+)\\s*}|(\\w+))\\s+from\\s+['\"]([^'\"]+)['\"]/g,\n    /from\\s+['\"]([^'\"]+)['\"]\\s+import/g,\n    /require\\s*\\(['\"]([^'\"]+)['\"]\\)/g,\n    /use\\s+(\\w+(?:::\\w+)*)/g,\n  ];\n\n  patterns.forEach((pattern) => {\n    let match;\n    while ((match = pattern.exec(code)) !== null) {\n      imports.push(match[3] || match[1] || match[2] || match[0]);\n    }\n  });\n\n  return [...new Set(imports)];\n}\n\n/**\n * Extract export statements\n */\nfunction extractExports(code: string): string[] {\n  const exports: string[] = [];\n  const patterns = [\n    /export\\s+(?:default\\s+)?(?:function|class|const|let|var)\\s+(\\w+)/g,\n    /export\\s*{\\s*([^}]+)\\s*}/g,\n    /pub\\s+(?:fn|struct|enum|trait|mod)\\s+(\\w+)/g,\n  ];\n\n  patterns.forEach((pattern) => {\n    let match;\n    while ((match = pattern.exec(code)) !== null) {\n      const names = (match[1] || \"\").split(\",\").map((s) => s.trim());\n      exports.push(...names.filter(Boolean));\n    }\n  });\n\n  return [...new Set(exports)];\n}\n\n/**\n * Extract function signatures\n */\nfunction extractFunctionSignatures(code: string): string[] {\n  const functions: string[] = [];\n  const patterns = [\n    /(?:async\\s+)?function\\s+(\\w+)/g,\n    /(\\w+)\\s*:\\s*(?:async\\s+)?\\([^)]*\\)\\s*=>/g,\n    /(?:const|let)\\s+(\\w+)\\s*=\\s*(?:async\\s+)?\\([^)]*\\)\\s*=>/g,\n    /fn\\s+(\\w+)/g,\n    /def\\s+(\\w+)/g,\n  ];\n\n  patterns.forEach((pattern) => {\n    let match;\n    while ((match = pattern.exec(code)) !== null) {\n      functions.push(match[1]);\n    }\n  });\n\n  return [...new Set(functions)];\n}\n\n/**\n * Extract class names\n */\nfunction extractClassNames(code: string): string[] {\n  const classes: string[] = [];\n  const patterns = [\n    /class\\s+(\\w+)/g,\n    /struct\\s+(\\w+)/g,\n    /interface\\s+(\\w+)/g,\n    /type\\s+(\\w+)\\s*=/g,\n  ];\n\n  patterns.forEach((pattern) => {\n    let match;\n    while ((match = pattern.exec(code)) !== null) {\n      classes.push(match[1]);\n    }\n  });\n\n  return [...new Set(classes)];\n}\n\n/**\n * Extract error patterns\n */\nfunction extractErrorPatterns(code: string): string[] {\n  const errors: string[] = [];\n  const lines = code.split(\"\\n\");\n\n  lines.forEach((line) => {\n    if (\n      line.includes(\"TODO\") ||\n      line.includes(\"FIXME\") ||\n      line.includes(\"HACK\") ||\n      line.includes(\"XXX\") ||\n      line.includes(\"BUG\")\n    ) {\n      errors.push(line.trim().slice(0, 100));\n    }\n  });\n\n  return errors.slice(0, 10);\n}\n\n/**\n * Truncate to target size\n */\nfunction truncateToTarget(text: string): string {\n  if (text.length <= TARGET_COMPRESSED_SIZE) {\n    return text;\n  }\n\n  return text.slice(0, TARGET_COMPRESSED_SIZE - 20) + \"\\n... (compressed)\";\n}\n\n/**\n * Calculate compression ratio\n */\nexport function getCompressionStats(\n  originalSize: number,\n  compressedSize: number\n): { ratio: number; saved: number; savedPercent: string } {\n  const saved = originalSize - compressedSize;\n  const ratio = originalSize / compressedSize;\n  const savedPercent = ((saved / originalSize) * 100).toFixed(1);\n\n  return { ratio, saved, savedPercent };\n}\n","import type { PlatformAdapter } from \"./contract.js\";\n\nexport interface ReadonlyAdapterRegistry {\n  resolve(platform: string): PlatformAdapter | null;\n  listPlatforms(): string[];\n}\n\nexport class AdapterRegistry implements ReadonlyAdapterRegistry {\n  private adapters = new Map<string, PlatformAdapter>();\n\n  register(adapter: PlatformAdapter): void {\n    this.adapters.set(adapter.platform, adapter);\n  }\n\n  resolve(platform: string): PlatformAdapter | null {\n    return this.adapters.get(platform) || null;\n  }\n\n  listPlatforms(): string[] {\n    return [...this.adapters.keys()].sort();\n  }\n}\n","import { generateId } from \"../utils/helpers.js\";\n\nexport type PlatformEventType = \"session_start\" | \"tool_observation\" | \"session_stop\";\n\nexport interface PlatformProjectContext {\n  platformProjectId?: string;\n  canonicalPath?: string;\n  cwd?: string;\n}\n\nexport interface PlatformEventBase {\n  eventId: string;\n  eventType: PlatformEventType;\n  platform: string;\n  contractVersion: string;\n  sessionId: string;\n  timestamp: number;\n  projectContext: PlatformProjectContext;\n}\n\nexport interface SessionStartPayload {\n  hookEventName?: string;\n  permissionMode?: string;\n  transcriptPath?: string;\n}\n\nexport interface ToolObservationPayload {\n  toolName?: string;\n  toolInput?: Record<string, unknown>;\n  toolResponse?: unknown;\n}\n\nexport interface SessionStopPayload {\n  transcriptPath?: string;\n}\n\nexport interface SessionStartEvent extends PlatformEventBase {\n  eventType: \"session_start\";\n  payload: SessionStartPayload;\n}\n\nexport interface ToolObservationEvent extends PlatformEventBase {\n  eventType: \"tool_observation\";\n  payload: ToolObservationPayload;\n}\n\nexport interface SessionStopEvent extends PlatformEventBase {\n  eventType: \"session_stop\";\n  payload: SessionStopPayload;\n}\n\nexport type PlatformEvent = SessionStartEvent | ToolObservationEvent | SessionStopEvent;\n\nexport function createEventId(): string {\n  return generateId();\n}\n","import {\n  createEventId,\n  type SessionStartEvent,\n  type SessionStopEvent,\n  type ToolObservationEvent,\n} from \"../events.js\";\nimport type { PlatformAdapter } from \"../contract.js\";\nimport type { HookInput } from \"../../types.js\";\n\nconst CONTRACT_VERSION = \"1.0.0\";\n\nexport function createAdapter(platform: string): PlatformAdapter {\n  function projectContext(input: HookInput) {\n    return {\n      platformProjectId: input.project_id,\n      canonicalPath: input.cwd,\n      cwd: input.cwd,\n    };\n  }\n\n  return {\n    platform,\n    contractVersion: CONTRACT_VERSION,\n\n    normalizeSessionStart(input: HookInput): SessionStartEvent {\n      return {\n        eventId: createEventId(),\n        eventType: \"session_start\",\n        platform,\n        contractVersion: input.contract_version || CONTRACT_VERSION,\n        sessionId: input.session_id,\n        timestamp: Date.now(),\n        projectContext: projectContext(input),\n        payload: {\n          hookEventName: input.hook_event_name,\n          permissionMode: input.permission_mode,\n          transcriptPath: input.transcript_path,\n        },\n      };\n    },\n\n    normalizeToolObservation(input: HookInput): ToolObservationEvent | null {\n      if (!input.tool_name) return null;\n      return {\n        eventId: createEventId(),\n        eventType: \"tool_observation\",\n        platform,\n        contractVersion: input.contract_version || CONTRACT_VERSION,\n        sessionId: input.session_id,\n        timestamp: Date.now(),\n        projectContext: projectContext(input),\n        payload: {\n          toolName: input.tool_name,\n          toolInput: input.tool_input,\n          toolResponse: input.tool_response,\n        },\n      };\n    },\n\n    normalizeSessionStop(input: HookInput): SessionStopEvent {\n      return {\n        eventId: createEventId(),\n        eventType: \"session_stop\",\n        platform,\n        contractVersion: input.contract_version || CONTRACT_VERSION,\n        sessionId: input.session_id,\n        timestamp: Date.now(),\n        projectContext: projectContext(input),\n        payload: {\n          transcriptPath: input.transcript_path,\n        },\n      };\n    },\n  };\n}\n","import { createAdapter } from \"./create-adapter.js\";\n\nexport const claudeAdapter = createAdapter(\"claude\");\n","import { createAdapter } from \"./create-adapter.js\";\n\nexport const opencodeAdapter = createAdapter(\"opencode\");\n","import type { HookInput } from \"../types.js\";\nimport type {\n  SessionStartEvent,\n  SessionStopEvent,\n  ToolObservationEvent,\n} from \"./events.js\";\n\nexport const SUPPORTED_ADAPTER_CONTRACT_MAJOR = 1;\n\nconst SEMVER_PATTERN = /^(\\d+)\\.(\\d+)\\.(\\d+)(?:[-+].*)?$/;\n\nexport interface ContractValidationResult {\n  compatible: boolean;\n  supportedMajor: number;\n  adapterMajor: number | null;\n  reason?: string;\n}\n\nexport function parseContractMajor(version: string): number | null {\n  const match = SEMVER_PATTERN.exec(version.trim());\n  if (!match) {\n    return null;\n  }\n  return Number(match[1]);\n}\n\nexport function validateAdapterContractVersion(\n  version: string,\n  supportedMajor = SUPPORTED_ADAPTER_CONTRACT_MAJOR\n): ContractValidationResult {\n  const adapterMajor = parseContractMajor(version);\n  if (adapterMajor === null) {\n    return {\n      compatible: false,\n      supportedMajor,\n      adapterMajor: null,\n      reason: \"invalid_contract_version\",\n    };\n  }\n\n  if (adapterMajor !== supportedMajor) {\n    return {\n      compatible: false,\n      supportedMajor,\n      adapterMajor,\n      reason: \"incompatible_contract_major\",\n    };\n  }\n\n  return {\n    compatible: true,\n    supportedMajor,\n    adapterMajor,\n  };\n}\n\nexport interface PlatformAdapter {\n  platform: string;\n  contractVersion: string;\n  normalizeSessionStart(input: HookInput): SessionStartEvent;\n  normalizeToolObservation(input: HookInput): ToolObservationEvent | null;\n  normalizeSessionStop(input: HookInput): SessionStopEvent;\n}\n","export const DIAGNOSTIC_RETENTION_DAYS = 30;\n\nexport type DiagnosticSeverity = \"warning\" | \"error\";\n\nexport interface AdapterDiagnostic {\n  diagnosticId: string;\n  timestamp: number;\n  platform: string;\n  errorType: string;\n  fieldNames?: string[];\n  severity: DiagnosticSeverity;\n  redacted: true;\n  retentionDays: number;\n  expiresAt: number;\n}\n","import { generateId } from \"../utils/helpers.js\";\nimport {\n  DIAGNOSTIC_RETENTION_DAYS,\n  type AdapterDiagnostic,\n  type DiagnosticSeverity,\n} from \"./diagnostics.js\";\n\nconst DAY_MS = 24 * 60 * 60 * 1000;\n\nexport interface CreateDiagnosticInput {\n  platform: string;\n  errorType: string;\n  fieldNames?: string[];\n  severity?: DiagnosticSeverity;\n  now?: number;\n}\n\nfunction sanitizeFieldNames(fieldNames: string[] | undefined): string[] | undefined {\n  if (!fieldNames || fieldNames.length === 0) {\n    return undefined;\n  }\n  return [...new Set(fieldNames)].slice(0, 20);\n}\n\n// TODO: FR-012/FR-016  This module creates diagnostic records in memory but does\n// not persist them to disk. Implement a DiagnosticPersistence layer that appends\n// records to a JSON file and prunes entries older than DIAGNOSTIC_RETENTION_DAYS.\nexport function createRedactedDiagnostic(input: CreateDiagnosticInput): AdapterDiagnostic {\n  const timestamp = input.now ?? Date.now();\n  return {\n    diagnosticId: generateId(),\n    timestamp,\n    platform: input.platform,\n    errorType: input.errorType,\n    fieldNames: sanitizeFieldNames(input.fieldNames),\n    severity: input.severity ?? \"warning\",\n    redacted: true,\n    retentionDays: DIAGNOSTIC_RETENTION_DAYS,\n    expiresAt: timestamp + (DIAGNOSTIC_RETENTION_DAYS * DAY_MS),\n  };\n}\n","import { resolve } from \"node:path\";\nimport type { PlatformProjectContext } from \"./events.js\";\n\nexport type ProjectIdentitySource =\n  | \"platform_project_id\"\n  | \"canonical_path\"\n  | \"unresolved\";\n\nexport interface ProjectIdentityResolution {\n  key: string | null;\n  source: ProjectIdentitySource;\n  canonicalPath?: string;\n}\n\nexport function resolveCanonicalProjectPath(\n  context: PlatformProjectContext\n): string | undefined {\n  if (context.canonicalPath) {\n    return resolve(context.canonicalPath);\n  }\n  if (context.cwd) {\n    return resolve(context.cwd);\n  }\n  return undefined;\n}\n\nexport function resolveProjectIdentityKey(\n  context: PlatformProjectContext\n): ProjectIdentityResolution {\n  if (context.platformProjectId && context.platformProjectId.trim().length > 0) {\n    return {\n      key: context.platformProjectId.trim(),\n      source: \"platform_project_id\",\n      canonicalPath: resolveCanonicalProjectPath(context),\n    };\n  }\n\n  const canonicalPath = resolveCanonicalProjectPath(context);\n  if (canonicalPath) {\n    return {\n      key: canonicalPath,\n      source: \"canonical_path\",\n      canonicalPath,\n    };\n  }\n\n  return {\n    key: null,\n    source: \"unresolved\",\n  };\n}\n","import {\n  SUPPORTED_ADAPTER_CONTRACT_MAJOR,\n  validateAdapterContractVersion,\n} from \"./contract.js\";\nimport { createRedactedDiagnostic } from \"./diagnostic-store.js\";\nimport type { AdapterDiagnostic } from \"./diagnostics.js\";\nimport type { PlatformEvent } from \"./events.js\";\nimport { resolveProjectIdentityKey } from \"./identity.js\";\n\nexport interface ProcessPlatformEventResult {\n  skipped: boolean;\n  reason?: string;\n  projectIdentityKey?: string;\n  diagnostic?: AdapterDiagnostic;\n}\n\nfunction skipWithDiagnostic(\n  platform: string,\n  errorType: string,\n  fieldNames?: string[]\n): ProcessPlatformEventResult {\n  // TODO: FR-012/FR-016  Diagnostics are created but not yet persisted.\n  // Implement DiagnosticPersistence to write records to disk and enforce\n  // the 30-day retention window (DIAGNOSTIC_RETENTION_DAYS expiry).\n  return {\n    skipped: true,\n    reason: errorType,\n    diagnostic: createRedactedDiagnostic({\n      platform,\n      errorType,\n      fieldNames,\n      severity: \"warning\",\n    }),\n  };\n}\n\nexport function processPlatformEvent(\n  event: PlatformEvent\n): ProcessPlatformEventResult {\n  const contractValidation = validateAdapterContractVersion(\n    event.contractVersion,\n    SUPPORTED_ADAPTER_CONTRACT_MAJOR\n  );\n  if (!contractValidation.compatible) {\n    return skipWithDiagnostic(event.platform, \"incompatible_contract_major\", [\"contractVersion\"]);\n  }\n\n  const identity = resolveProjectIdentityKey(event.projectContext);\n  if (!identity.key) {\n    return skipWithDiagnostic(event.platform, \"missing_project_identity\", [\n      \"platformProjectId\",\n      \"canonicalPath\",\n      \"cwd\",\n    ]);\n  }\n\n  return {\n    skipped: false,\n    projectIdentityKey: identity.key,\n  };\n}\n","import { AdapterRegistry } from \"./registry.js\";\nimport type { ReadonlyAdapterRegistry } from \"./registry.js\";\nimport { claudeAdapter, opencodeAdapter } from \"./adapters/index.js\";\n\nexport * from \"./contract.js\";\nexport * from \"./diagnostics.js\";\nexport * from \"./diagnostic-store.js\";\nexport * from \"./events.js\";\nexport * from \"./identity.js\";\nexport * from \"./path-policy.js\";\nexport * from \"./pipeline.js\";\nexport * from \"./platform-detector.js\";\nexport type { ReadonlyAdapterRegistry } from \"./registry.js\";\nexport { AdapterRegistry } from \"./registry.js\";\nexport * from \"./adapters/index.js\";\n\nlet defaultRegistry: AdapterRegistry | null = null;\n\nexport function getDefaultAdapterRegistry(): ReadonlyAdapterRegistry {\n  if (!defaultRegistry) {\n    defaultRegistry = new AdapterRegistry();\n    defaultRegistry.register(claudeAdapter);\n    defaultRegistry.register(opencodeAdapter);\n  }\n\n  return defaultRegistry;\n}\n\nexport function resetDefaultAdapterRegistry(): void {\n  defaultRegistry = null;\n}\n","#!/usr/bin/env node\n/**\n * Memvid Mind - Post Tool Use Hook\n *\n * Captures observations after each tool execution through\n * platform adapters and a shared fail-open pipeline.\n */\n\nimport { getMind } from \"../core/mind.js\";\nimport {\n  readStdin,\n  writeOutput,\n  debug,\n  classifyObservationType,\n} from \"../utils/helpers.js\";\nimport {\n  compressToolOutput,\n  getCompressionStats,\n} from \"../utils/compression.js\";\nimport type { HookInput } from \"../types.js\";\nimport {\n  detectPlatform,\n  getDefaultAdapterRegistry,\n  processPlatformEvent,\n} from \"../platforms/index.js\";\nimport { fileURLToPath } from \"node:url\";\n\nconst OBSERVED_TOOLS = new Set([\n  \"Read\",\n  \"Edit\",\n  \"Write\",\n  \"Update\",\n  \"Bash\",\n  \"Grep\",\n  \"Glob\",\n  \"WebFetch\",\n  \"WebSearch\",\n  \"Task\",\n  \"NotebookEdit\",\n]);\n\nconst MIN_OUTPUT_LENGTH = 50;\nconst DEDUP_WINDOW_MS = 60000;\nconst ALWAYS_CAPTURE_TOOLS = new Set([\"Edit\", \"Write\", \"Update\", \"NotebookEdit\"]);\nconst MAX_OUTPUT_LENGTH = 2500;\n\nconst recentObservations = new Map<string, number>();\n\nfunction getObservationKey(toolName: string, toolInput: Record<string, unknown> | undefined): string {\n  const inputStr = toolInput ? JSON.stringify(toolInput).slice(0, 200) : \"\";\n  return `${toolName}:${inputStr}`;\n}\n\nfunction isDuplicate(key: string): boolean {\n  const lastSeen = recentObservations.get(key);\n  if (!lastSeen) return false;\n  return Date.now() - lastSeen < DEDUP_WINDOW_MS;\n}\n\nfunction markObserved(key: string): void {\n  recentObservations.set(key, Date.now());\n  if (recentObservations.size > 100) {\n    const now = Date.now();\n    for (const [k, v] of recentObservations.entries()) {\n      if (now - v > DEDUP_WINDOW_MS * 2) {\n        recentObservations.delete(k);\n      }\n    }\n  }\n}\n\nfunction generateSummary(\n  toolName: string,\n  toolInput: Record<string, unknown> | undefined,\n  toolOutput: string\n): string {\n  switch (toolName) {\n    case \"Read\": {\n      const path = (toolInput?.file_path as string | undefined) ||\n        (toolInput?.filePath as string | undefined);\n      const fileName = path?.split(\"/\").pop() || \"file\";\n      const lines = toolOutput.split(\"\\n\").length;\n      return `Read ${fileName} (${lines} lines)`;\n    }\n    case \"Edit\":\n    case \"Update\": {\n      const path = (toolInput?.file_path as string | undefined) ||\n        (toolInput?.filePath as string | undefined);\n      const fileName = path?.split(\"/\").pop() || \"file\";\n      return `Edited ${fileName}`;\n    }\n    case \"Write\": {\n      const path = (toolInput?.file_path as string | undefined) ||\n        (toolInput?.filePath as string | undefined);\n      const fileName = path?.split(\"/\").pop() || \"file\";\n      return `Created ${fileName}`;\n    }\n    case \"Bash\": {\n      const cmd = toolInput?.command as string | undefined;\n      const shortCmd = cmd?.split(\"\\n\")[0].slice(0, 50) || \"command\";\n      const hasError = toolOutput.toLowerCase().includes(\"error\") || toolOutput.toLowerCase().includes(\"failed\");\n      return hasError ? `Command failed: ${shortCmd}` : `Ran: ${shortCmd}`;\n    }\n    case \"Grep\": {\n      const pattern = toolInput?.pattern as string | undefined;\n      const matches = toolOutput.split(\"\\n\").filter(Boolean).length;\n      return `Found ${matches} matches for \"${pattern?.slice(0, 30)}\"`;\n    }\n    case \"Glob\": {\n      const pattern = toolInput?.pattern as string | undefined;\n      const matches = toolOutput.split(\"\\n\").filter(Boolean).length;\n      return `Found ${matches} files matching \"${pattern?.slice(0, 30)}\"`;\n    }\n    case \"WebFetch\":\n    case \"WebSearch\": {\n      const url = (toolInput?.url as string | undefined) || (toolInput?.query as string | undefined);\n      return `Fetched: ${url?.slice(0, 50)}`;\n    }\n    default:\n      return `${toolName} completed`;\n  }\n}\n\nfunction extractMetadata(\n  toolName: string,\n  toolInput: Record<string, unknown> | undefined,\n  platform: string,\n  projectIdentityKey: string\n): Record<string, unknown> {\n  const metadata: Record<string, unknown> = {\n    platform,\n    projectIdentityKey,\n  };\n\n  if (!toolInput) return metadata;\n\n  switch (toolName) {\n    case \"Read\":\n    case \"Edit\":\n    case \"Write\":\n    case \"Update\": {\n      const filePath = toolInput.file_path || toolInput.filePath;\n      if (filePath) {\n        metadata.files = [filePath];\n      }\n      break;\n    }\n    case \"Bash\":\n      if (toolInput.command) {\n        metadata.command = (toolInput.command as string).slice(0, 200);\n      }\n      break;\n    case \"Grep\":\n    case \"Glob\":\n      if (toolInput.pattern) {\n        metadata.pattern = toolInput.pattern;\n      }\n      if (toolInput.path) {\n        metadata.searchPath = toolInput.path;\n      }\n      break;\n  }\n\n  return metadata;\n}\n\nexport async function runPostToolUseHook(): Promise<void> {\n  try {\n    const input = await readStdin();\n    const hookInput: HookInput = JSON.parse(input);\n\n    const platform = detectPlatform(hookInput);\n    const adapter = getDefaultAdapterRegistry().resolve(platform);\n    if (!adapter) {\n      debug(`Skipping capture: unsupported platform ${platform}`);\n      writeOutput({ continue: true });\n      return;\n    }\n\n    const normalized = adapter.normalizeToolObservation(hookInput);\n    if (!normalized) {\n      writeOutput({ continue: true });\n      return;\n    }\n\n    const pipelineResult = processPlatformEvent(normalized);\n    if (pipelineResult.skipped || !pipelineResult.projectIdentityKey) {\n      debug(`Skipping event due to pipeline result: ${pipelineResult.reason}`);\n      writeOutput({ continue: true });\n      return;\n    }\n\n    const { toolName, toolInput, toolResponse } = normalized.payload;\n    if (!toolName || !OBSERVED_TOOLS.has(toolName)) {\n      writeOutput({ continue: true });\n      return;\n    }\n\n    const dedupKey = getObservationKey(toolName, toolInput);\n    if (isDuplicate(dedupKey)) {\n      debug(`Skipping duplicate observation: ${toolName}`);\n      writeOutput({ continue: true });\n      return;\n    }\n\n    const rawOutput = typeof toolResponse === \"string\"\n      ? toolResponse\n      : JSON.stringify(toolResponse, null, 2);\n\n    const alwaysCapture = ALWAYS_CAPTURE_TOOLS.has(toolName);\n    if (!alwaysCapture && (!rawOutput || rawOutput.length < MIN_OUTPUT_LENGTH)) {\n      writeOutput({ continue: true });\n      return;\n    }\n\n    let effectiveOutput = rawOutput || \"\";\n    if (alwaysCapture && effectiveOutput.length < MIN_OUTPUT_LENGTH) {\n      const filePath =\n        (toolInput?.file_path as string | undefined) ||\n        (toolInput?.filePath as string | undefined) ||\n        \"unknown file\";\n      const fileName = filePath.split(\"/\").pop() || \"file\";\n      effectiveOutput = `File modified: ${fileName}\\nPath: ${filePath}\\nTool: ${toolName}`;\n    }\n\n    if (\n      effectiveOutput.includes(\"<system-reminder>\") ||\n      effectiveOutput.includes(\"<memvid-mind-context>\")\n    ) {\n      writeOutput({ continue: true });\n      return;\n    }\n\n    const { compressed, wasCompressed, originalSize } = compressToolOutput(\n      toolName,\n      toolInput,\n      effectiveOutput\n    );\n\n    if (wasCompressed) {\n      const stats = getCompressionStats(originalSize, compressed.length);\n      debug(`Compression: ${stats.savedPercent}% (${originalSize} -> ${compressed.length})`);\n    }\n\n    const mind = await getMind();\n    const observationType = classifyObservationType(toolName, compressed);\n    const summary = generateSummary(toolName, toolInput, effectiveOutput);\n    const content = compressed.length > MAX_OUTPUT_LENGTH\n      ? `${compressed.slice(0, MAX_OUTPUT_LENGTH)}\\n... (truncated${wasCompressed ? ', compressed' : ''})`\n      : compressed;\n\n    const metadata = extractMetadata(\n      toolName,\n      toolInput,\n      platform,\n      pipelineResult.projectIdentityKey\n    );\n\n    if (wasCompressed) {\n      metadata.compressed = true;\n      metadata.originalSize = originalSize;\n      metadata.compressedSize = compressed.length;\n    }\n\n    await mind.remember({\n      type: observationType,\n      summary,\n      content,\n      tool: toolName,\n      metadata,\n    });\n\n    markObserved(dedupKey);\n    writeOutput({ continue: true });\n  } catch (error) {\n    debug(`Error: ${error}`);\n    writeOutput({ continue: true });\n  }\n}\n\nif (process.argv[1] && fileURLToPath(import.meta.url) === process.argv[1]) {\n  void runPostToolUseHook();\n}\n"]}