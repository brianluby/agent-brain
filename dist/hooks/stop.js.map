{"version":3,"sources":["../../src/types.ts","../../src/utils/helpers.ts","../../src/utils/memvid-lock.ts","../../src/platforms/path-policy.ts","../../src/platforms/platform-detector.ts","../../src/core/mind.ts","../../src/platforms/registry.ts","../../src/platforms/events.ts","../../src/platforms/adapters/create-adapter.ts","../../src/platforms/adapters/claude.ts","../../src/platforms/adapters/opencode.ts","../../src/platforms/contract.ts","../../src/platforms/diagnostics.ts","../../src/platforms/diagnostic-store.ts","../../src/platforms/identity.ts","../../src/platforms/pipeline.ts","../../src/platforms/index.ts","../../src/hooks/stop.ts"],"names":["resolve","pathRelative","dirname","mkdir","existsSync","renameSync","unlinkSync","lockfile"],"mappings":"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","file":"stop.js","sourcesContent":["/**\n * Memvid Mind - Type Definitions\n *\n * Core types for multi-platform agent memory persistence.\n */\n\n/** Observation captured from tool use */\nexport interface Observation {\n  id: string;\n  timestamp: number;\n  type: ObservationType;\n  tool?: string;\n  summary: string;\n  content: string;\n  metadata?: ObservationMetadata;\n}\n\n/** Types of observations */\nexport type ObservationType =\n  | \"discovery\"      // New information discovered\n  | \"decision\"       // Decision made\n  | \"problem\"        // Problem identified\n  | \"solution\"       // Solution implemented\n  | \"pattern\"        // Pattern recognized\n  | \"warning\"        // Warning or concern\n  | \"success\"        // Successful outcome\n  | \"refactor\"       // Code refactored\n  | \"bugfix\"         // Bug fixed\n  | \"feature\";       // Feature added\n\n/** Metadata attached to observations */\nexport interface ObservationMetadata {\n  files?: string[];\n  functions?: string[];\n  error?: string;\n  confidence?: number;\n  tags?: string[];\n  sessionId?: string;\n  [key: string]: unknown;  // Allow additional properties\n}\n\n/** Session summary stored at end of session */\nexport interface SessionSummary {\n  id: string;\n  startTime: number;\n  endTime: number;\n  observationCount: number;\n  keyDecisions: string[];\n  filesModified: string[];\n  summary: string;\n}\n\n/** Context injected at session start */\nexport interface InjectedContext {\n  recentObservations: Observation[];\n  relevantMemories: Observation[];\n  sessionSummaries: SessionSummary[];\n  tokenCount: number;\n}\n\n/** Configuration for Memvid Mind */\nexport interface MindConfig {\n  /** Path to the memory file (default: .agent-brain/mind.mv2 in project root) */\n  memoryPath: string;\n  /** Maximum observations to inject at session start */\n  maxContextObservations: number;\n  /** Maximum tokens for context injection */\n  maxContextTokens: number;\n  /** Whether to auto-compress observations */\n  autoCompress: boolean;\n  /** Minimum confidence for storing observations */\n  minConfidence: number;\n  /** Enable debug logging */\n  debug: boolean;\n}\n\n/** Default configuration */\nexport const DEFAULT_MEMORY_PATH = \".agent-brain/mind.mv2\";\n\n/** Default configuration */\nexport const DEFAULT_CONFIG: MindConfig = {\n  memoryPath: DEFAULT_MEMORY_PATH,\n  maxContextObservations: 20,\n  maxContextTokens: 2000,\n  autoCompress: true,\n  minConfidence: 0.6,\n  debug: false,\n};\n\n/** Hook input from the host coding assistant (Claude Code, OpenCode, etc.) */\nexport interface HookInput {\n  session_id: string;\n  platform?: string;\n  contract_version?: string;\n  project_id?: string;\n  transcript_path?: string;\n  cwd?: string;\n  hook_event_name?: string;\n  permission_mode?: string;\n  tool_name?: string;\n  tool_input?: Record<string, unknown>;\n  tool_response?: unknown; // Can be object or string depending on tool\n  tool_use_id?: string;\n}\n\n/** Hook output to Claude Code */\nexport interface HookOutput {\n  continue?: boolean;\n  result?: string;\n  decision?: \"block\" | \"approve\" | \"modify\";\n  reason?: string;\n  modified_input?: Record<string, unknown>;\n}\n\n/** Search result from memory */\nexport interface MemorySearchResult {\n  observation: Observation;\n  score: number;\n  snippet: string;\n}\n\n/** Statistics about the mind file */\nexport interface MindStats {\n  totalObservations: number;\n  totalSessions: number;\n  oldestMemory: number;\n  newestMemory: number;\n  fileSize: number;\n  topTypes: Record<ObservationType, number>;\n}\n","/**\n * Memvid Mind - Utility Helpers\n */\n\nimport { randomBytes } from \"node:crypto\";\n\n/**\n * Generate a unique ID\n */\nexport function generateId(): string {\n  return randomBytes(8).toString(\"hex\");\n}\n\n/**\n * Estimate token count for text (rough approximation)\n * ~4 characters per token for English text\n */\nexport function estimateTokens(text: string): number {\n  return Math.ceil(text.length / 4);\n}\n\n/**\n * Truncate text to fit within token limit\n */\nexport function truncateToTokens(text: string, maxTokens: number): string {\n  const maxChars = maxTokens * 4;\n  if (text.length <= maxChars) return text;\n  return text.slice(0, maxChars - 3) + \"...\";\n}\n\n/**\n * Format timestamp to human-readable string\n */\nexport function formatTimestamp(ts: number): string {\n  const date = new Date(ts);\n  const now = new Date();\n  const diffMs = now.getTime() - date.getTime();\n  const diffMins = Math.floor(diffMs / 60000);\n  const diffHours = Math.floor(diffMs / 3600000);\n  const diffDays = Math.floor(diffMs / 86400000);\n\n  if (diffMins < 1) return \"just now\";\n  if (diffMins < 60) return `${diffMins}m ago`;\n  if (diffHours < 24) return `${diffHours}h ago`;\n  if (diffDays < 7) return `${diffDays}d ago`;\n\n  return date.toLocaleDateString();\n}\n\n/**\n * Parse JSON safely\n */\nexport function safeJsonParse<T>(text: string, fallback: T): T {\n  try {\n    return JSON.parse(text) as T;\n  } catch {\n    return fallback;\n  }\n}\n\n/**\n * Read all stdin as string\n */\nexport async function readStdin(): Promise<string> {\n  const chunks: Buffer[] = [];\n\n  return new Promise((resolve, reject) => {\n    process.stdin.on(\"data\", (chunk) => chunks.push(chunk));\n    process.stdin.on(\"end\", () => resolve(Buffer.concat(chunks).toString(\"utf8\")));\n    process.stdin.on(\"error\", reject);\n  });\n}\n\n/**\n * Write JSON to stdout and exit immediately\n * (Prevents SDK background tasks from blocking process exit)\n */\nexport function writeOutput(output: unknown): never {\n  console.log(JSON.stringify(output));\n  process.exit(0);\n}\n\n/**\n * Log debug message to stderr\n */\nexport function debug(message: string): void {\n  if (process.env.MEMVID_MIND_DEBUG === \"1\") {\n    console.error(`[memvid-mind] ${message}`);\n  }\n}\n\n/**\n * Extract key information from tool output\n */\nexport function extractKeyInfo(toolName: string, output: string): string {\n  // Truncate very long outputs\n  const maxLength = 2000;\n  const truncated = output.length > maxLength\n    ? output.slice(0, maxLength) + \"\\n... (truncated)\"\n    : output;\n\n  // Tool-specific extraction\n  switch (toolName) {\n    case \"Read\":\n      // Extract file summary from read output\n      return extractFileReadSummary(truncated);\n    case \"Bash\":\n      // Extract command summary\n      return extractBashSummary(truncated);\n    case \"Edit\":\n      // Extract edit summary\n      return extractEditSummary(truncated);\n    case \"Grep\":\n    case \"Glob\":\n      // Extract search summary\n      return extractSearchSummary(truncated);\n    default:\n      return truncated;\n  }\n}\n\nfunction extractFileReadSummary(output: string): string {\n  const lines = output.split(\"\\n\");\n  if (lines.length <= 20) return output;\n  return `${lines.slice(0, 10).join(\"\\n\")}\\n... (${lines.length} lines total)`;\n}\n\nfunction extractBashSummary(output: string): string {\n  const lines = output.split(\"\\n\");\n  if (lines.length <= 30) return output;\n  return [\n    ...lines.slice(0, 10),\n    `... (${lines.length - 20} lines omitted)`,\n    ...lines.slice(-10),\n  ].join(\"\\n\");\n}\n\nfunction extractEditSummary(output: string): string {\n  // Edits are usually compact, return as-is\n  return output;\n}\n\nfunction extractSearchSummary(output: string): string {\n  const lines = output.split(\"\\n\").filter(Boolean);\n  if (lines.length <= 20) return output;\n  return [\n    ...lines.slice(0, 15),\n    `... and ${lines.length - 15} more results`,\n  ].join(\"\\n\");\n}\n\n/**\n * Classify observation type from tool and output\n */\nexport function classifyObservationType(\n  toolName: string,\n  output: string\n): \"discovery\" | \"decision\" | \"problem\" | \"solution\" | \"pattern\" | \"warning\" | \"success\" | \"refactor\" | \"bugfix\" | \"feature\" {\n  const lowerOutput = output.toLowerCase();\n\n  // Error detection\n  if (\n    lowerOutput.includes(\"error\") ||\n    lowerOutput.includes(\"failed\") ||\n    lowerOutput.includes(\"exception\")\n  ) {\n    return \"problem\";\n  }\n\n  // Success detection\n  if (\n    lowerOutput.includes(\"success\") ||\n    lowerOutput.includes(\"passed\") ||\n    lowerOutput.includes(\"completed\")\n  ) {\n    return \"success\";\n  }\n\n  // Warning detection\n  if (lowerOutput.includes(\"warning\") || lowerOutput.includes(\"deprecated\")) {\n    return \"warning\";\n  }\n\n  // Tool-based classification\n  switch (toolName) {\n    case \"Read\":\n    case \"Glob\":\n    case \"Grep\":\n      return \"discovery\";\n    case \"Edit\":\n      if (lowerOutput.includes(\"fix\") || lowerOutput.includes(\"bug\")) {\n        return \"bugfix\";\n      }\n      return \"refactor\";\n    case \"Write\":\n      return \"feature\";\n    default:\n      return \"discovery\";\n  }\n}\n","import lockfile from \"proper-lockfile\";\nimport { mkdir, open } from \"node:fs/promises\";\nimport { dirname } from \"node:path\";\n\nconst LOCK_OPTIONS = {\n  stale: 30000,\n  retries: {\n    retries: 1000,\n    minTimeout: 5,\n    maxTimeout: 50,\n  },\n} as const;\n\nexport async function withMemvidLock<T>(\n  lockPath: string,\n  fn: () => Promise<T>\n): Promise<T> {\n  await mkdir(dirname(lockPath), { recursive: true });\n  const handle = await open(lockPath, \"a\");\n  await handle.close();\n\n  const release = await lockfile.lock(lockPath, LOCK_OPTIONS);\n  try {\n    return await fn();\n  } finally {\n    await release();\n  }\n}\n","import { existsSync } from \"node:fs\";\nimport { isAbsolute, relative as pathRelative, resolve, sep } from \"node:path\";\n\nexport type MemoryPathMode = \"legacy_first\" | \"platform_opt_in\";\n\nexport interface MemoryPathPolicyInput {\n  projectDir: string;\n  platform: string;\n  defaultRelativePath: string;\n  platformRelativePath?: string;\n  platformOptIn?: boolean;\n  legacyRelativePaths?: string[];\n}\n\nexport interface MemoryMigrationSuggestion {\n  fromPath: string;\n  toPath: string;\n}\n\nexport interface MemoryPathPolicyResult {\n  mode: MemoryPathMode;\n  memoryPath: string;\n  canonicalPath: string;\n  migrationSuggestion?: MemoryMigrationSuggestion;\n}\n\nfunction defaultPlatformRelativePath(platform: string): string {\n  const normalizedPlatform = platform.trim().toLowerCase();\n  const safePlatform = normalizedPlatform\n    .replace(/[^a-z0-9_-]/g, \"-\")\n    .replace(/^-+|-+$/g, \"\") || \"unknown\";\n  return `.agent-brain/mind-${safePlatform}.mv2`;\n}\n\nfunction resolveInsideProject(projectDir: string, candidatePath: string): string {\n  if (isAbsolute(candidatePath)) {\n    return resolve(candidatePath);\n  }\n  const root = resolve(projectDir);\n  const resolved = resolve(root, candidatePath);\n  const rel = pathRelative(root, resolved);\n  if (rel === \"..\" || rel.startsWith(`..${sep}`)) {\n    throw new Error(\"Resolved memory path must stay inside projectDir\");\n  }\n  return resolved;\n}\n\nexport function resolveMemoryPathPolicy(input: MemoryPathPolicyInput): MemoryPathPolicyResult {\n  const mode: MemoryPathMode = input.platformOptIn ? \"platform_opt_in\" : \"legacy_first\";\n  const canonicalRelativePath = input.platformOptIn\n    ? input.platformRelativePath || defaultPlatformRelativePath(input.platform)\n    : input.defaultRelativePath;\n  const canonicalPath = resolveInsideProject(input.projectDir, canonicalRelativePath);\n\n  if (existsSync(canonicalPath)) {\n    return {\n      mode,\n      memoryPath: canonicalPath,\n      canonicalPath,\n    };\n  }\n\n  const fallbackPaths = (input.legacyRelativePaths || [])\n    .map((relativePath) => resolveInsideProject(input.projectDir, relativePath));\n\n  for (const fallbackPath of fallbackPaths) {\n    if (existsSync(fallbackPath)) {\n      return {\n        mode,\n        memoryPath: fallbackPath,\n        canonicalPath,\n        migrationSuggestion: {\n          fromPath: fallbackPath,\n          toPath: canonicalPath,\n        },\n      };\n    }\n  }\n\n  if (input.platformOptIn) {\n    return {\n      mode: \"platform_opt_in\",\n      memoryPath: canonicalPath,\n      canonicalPath,\n    };\n  }\n\n  return {\n    mode: \"legacy_first\",\n    memoryPath: canonicalPath,\n    canonicalPath,\n  };\n}\n","import type { HookInput } from \"../types.js\";\n\nfunction normalizePlatform(value: string | undefined): string | undefined {\n  if (!value) return undefined;\n  const normalized = value.trim().toLowerCase();\n  return normalized.length > 0 ? normalized : undefined;\n}\n\nexport function detectPlatformFromEnv(): string {\n  const explicitFromEnv = normalizePlatform(process.env.MEMVID_PLATFORM);\n  if (explicitFromEnv) {\n    return explicitFromEnv;\n  }\n\n  if (process.env.OPENCODE === \"1\") {\n    return \"opencode\";\n  }\n\n  return \"claude\";\n}\n\nexport function detectPlatform(input: HookInput): string {\n  const explicitFromHook = normalizePlatform(input.platform);\n  if (explicitFromHook) {\n    return explicitFromHook;\n  }\n\n  return detectPlatformFromEnv();\n}\n","/**\n * Memvid Mind - Core Engine\n *\n * The brain behind Claude's persistent memory.\n * Stores everything in ONE portable .memvid file.\n */\n\n// Use dynamic import to allow smart-install to run first\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Memvid = any;\n\nimport { existsSync, readdirSync, unlinkSync } from \"node:fs\";\nimport { resolve, dirname } from \"node:path\";\nimport { mkdir } from \"node:fs/promises\";\nimport {\n  type Observation,\n  type ObservationType,\n  type SessionSummary,\n  type InjectedContext,\n  type MindConfig,\n  type MindStats,\n  type MemorySearchResult,\n  DEFAULT_CONFIG,\n  DEFAULT_MEMORY_PATH,\n} from \"../types.js\";\nimport { generateId, estimateTokens } from \"../utils/helpers.js\";\nimport { withMemvidLock } from \"../utils/memvid-lock.js\";\nimport { resolveMemoryPathPolicy } from \"../platforms/path-policy.js\";\nimport { detectPlatformFromEnv } from \"../platforms/platform-detector.js\";\n\n/**\n * Prune old backup files, keeping only the most recent N\n */\nfunction pruneBackups(memoryPath: string, keepCount: number): void {\n  try {\n    const dir = dirname(memoryPath);\n    const baseName = memoryPath.split(\"/\").pop() || \"mind.mv2\";\n    const backupPattern = new RegExp(`^${baseName.replace(\".\", \"\\\\.\")}\\\\.backup-\\\\d+$`);\n\n    const files = readdirSync(dir);\n    const backups = files\n      .filter(f => backupPattern.test(f))\n      .map(f => ({\n        name: f,\n        path: resolve(dir, f),\n        time: parseInt(f.split(\"-\").pop() || \"0\", 10),\n      }))\n      .sort((a, b) => b.time - a.time); // newest first\n\n    // Delete old backups beyond keepCount\n    for (let i = keepCount; i < backups.length; i++) {\n      try {\n        unlinkSync(backups[i].path);\n        console.error(`[memvid-mind] Pruned old backup: ${backups[i].name}`);\n      } catch {\n        // Ignore errors deleting backups\n      }\n    }\n  } catch {\n    // Ignore errors during pruning\n  }\n}\n\n// Lazy-loaded SDK functions\nlet sdkLoaded = false;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet use: any;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet create: any;\n\nasync function loadSDK(): Promise<void> {\n  if (sdkLoaded) return;\n  const sdk = await import(\"@memvid/sdk\");\n  use = sdk.use;\n  create = sdk.create;\n  sdkLoaded = true;\n}\n\nconst OBSERVATION_TYPE_KEYS: ObservationType[] = [\n  \"discovery\",\n  \"decision\",\n  \"problem\",\n  \"solution\",\n  \"pattern\",\n  \"warning\",\n  \"success\",\n  \"refactor\",\n  \"bugfix\",\n  \"feature\",\n];\n\nconst OBSERVATION_TYPE_SET = new Set<ObservationType>(OBSERVATION_TYPE_KEYS);\n\nfunction emptyTypeCounts(): Record<ObservationType, number> {\n  return {\n    discovery: 0,\n    decision: 0,\n    problem: 0,\n    solution: 0,\n    pattern: 0,\n    warning: 0,\n    success: 0,\n    refactor: 0,\n    bugfix: 0,\n    feature: 0,\n  };\n}\n\n/**\n * Mind - Claude's portable memory engine\n *\n * @example\n * ```typescript\n * const mind = await Mind.open();\n * await mind.remember({\n *   type: \"decision\",\n *   summary: \"Chose React over Vue for frontend\",\n *   content: \"Decision rationale: team familiarity, ecosystem...\"\n * });\n *\n * const context = await mind.getContext(\"authentication\");\n * ```\n */\nexport class Mind {\n  private memvid: Memvid;\n  private config: MindConfig;\n  private memoryPath: string;\n  private sessionId: string;\n  private sessionStartTime: number;\n  private sessionObservationCount = 0;\n  private cachedStats: MindStats | null = null;\n  private cachedStatsFrameCount = -1;\n  private initialized = false;\n\n  private constructor(memvid: Memvid, config: MindConfig, memoryPath: string) {\n    this.memvid = memvid;\n    this.config = config;\n    this.memoryPath = memoryPath;\n    this.sessionId = generateId();\n    this.sessionStartTime = Date.now();\n  }\n\n  /**\n   * Open or create a Mind instance\n   */\n  static async open(configOverrides: Partial<MindConfig> = {}): Promise<Mind> {\n    // Load SDK dynamically (allows smart-install to run first)\n    await loadSDK();\n\n    const config = { ...DEFAULT_CONFIG, ...configOverrides };\n\n    // Resolve path relative to project dir from host environment\n    const projectDir = process.env.CLAUDE_PROJECT_DIR\n      || process.env.OPENCODE_PROJECT_DIR\n      || process.cwd();\n    const platform = detectPlatformFromEnv();\n    const optIn = process.env.MEMVID_PLATFORM_PATH_OPT_IN === \"1\";\n    const legacyFallbacks = config.memoryPath === DEFAULT_MEMORY_PATH ? [\".claude/mind.mv2\"] : [];\n    const pathPolicy = resolveMemoryPathPolicy({\n      projectDir,\n      platform,\n      defaultRelativePath: config.memoryPath,\n      legacyRelativePaths: legacyFallbacks,\n      platformRelativePath: process.env.MEMVID_PLATFORM_MEMORY_PATH,\n      platformOptIn: optIn,\n    });\n    const memoryPath = pathPolicy.memoryPath;\n    const memoryDir = dirname(memoryPath);\n\n    // Ensure directory exists\n    await mkdir(memoryDir, { recursive: true });\n\n    // Open or create the memvid file\n    let memvid: Memvid;\n    const MAX_FILE_SIZE_MB = 100; // Files over 100MB are likely corrupted\n    const lockPath = `${memoryPath}.lock`;\n\n    await withMemvidLock(lockPath, async () => {\n      if (!existsSync(memoryPath)) {\n        memvid = await create(memoryPath, \"basic\");\n        return;\n      }\n\n      // Check file size - very large files are likely corrupted and will hang\n      const { statSync, renameSync, unlinkSync } = await import(\"node:fs\");\n      const fileSize = statSync(memoryPath).size;\n      const fileSizeMB = fileSize / (1024 * 1024);\n\n      if (fileSizeMB > MAX_FILE_SIZE_MB) {\n        console.error(`[memvid-mind] Memory file too large (${fileSizeMB.toFixed(1)}MB), likely corrupted. Creating fresh memory...`);\n        const backupPath = `${memoryPath}.backup-${Date.now()}`;\n        try { renameSync(memoryPath, backupPath); } catch { /* ignore */ }\n        memvid = await create(memoryPath, \"basic\");\n        return;\n      }\n\n      try {\n        memvid = await use(\"basic\", memoryPath);\n      } catch (openError: unknown) {\n        const errorMessage = openError instanceof Error ? openError.message : String(openError);\n        // Handle corrupted or incompatible memory files\n        if (errorMessage.includes(\"Deserialization\") ||\n            errorMessage.includes(\"UnexpectedVariant\") ||\n            errorMessage.includes(\"Invalid\") ||\n            errorMessage.includes(\"corrupt\") ||\n            errorMessage.includes(\"validation failed\") ||\n            errorMessage.includes(\"unable to recover\") ||\n            errorMessage.includes(\"table of contents\")) {\n          console.error(\"[memvid-mind] Memory file corrupted, creating fresh memory...\");\n          const backupPath = `${memoryPath}.backup-${Date.now()}`;\n          try {\n            renameSync(memoryPath, backupPath);\n          } catch {\n            try { unlinkSync(memoryPath); } catch { /* ignore */ }\n          }\n          memvid = await create(memoryPath, \"basic\");\n          return;\n        }\n        throw openError;\n      }\n    });\n\n    const mind = new Mind(memvid, config, memoryPath);\n    mind.initialized = true;\n\n    // Prune old backups (keep only most recent 3)\n    pruneBackups(memoryPath, 3);\n\n    if (config.debug) {\n      console.error(`[memvid-mind] Opened: ${memoryPath}`);\n    }\n\n    return mind;\n  }\n\n  private async withLock<T>(fn: () => Promise<T>): Promise<T> {\n    const memoryPath = this.getMemoryPath();\n    const lockPath = `${memoryPath}.lock`;\n    return withMemvidLock(lockPath, fn);\n  }\n\n  /**\n   * Remember an observation\n   */\n  async remember(input: {\n    type: ObservationType;\n    summary: string;\n    content: string;\n    tool?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<string> {\n    const observation: Observation = {\n      id: generateId(),\n      timestamp: Date.now(),\n      type: input.type,\n      tool: input.tool,\n      summary: input.summary,\n      content: input.content,\n      metadata: {\n        ...input.metadata,\n        sessionId: this.sessionId,\n      },\n    };\n\n    const frameId = await this.withLock(async () => {\n      return this.memvid.put({\n        title: `[${observation.type}] ${observation.summary}`,\n        label: observation.type,\n        text: observation.content,\n        metadata: {\n          observationId: observation.id,\n          timestamp: observation.timestamp,\n          tool: observation.tool,\n          sessionId: this.sessionId,\n          ...observation.metadata,\n        },\n        tags: [\n          observation.type,\n          `session:${this.sessionId}`,\n          observation.tool ? `tool:${observation.tool}` : undefined,\n        ].filter(Boolean) as string[],\n      });\n    });\n\n    if (this.config.debug) {\n      console.error(`[memvid-mind] Remembered: ${observation.summary}`);\n    }\n\n    this.sessionObservationCount += 1;\n    this.cachedStats = null;\n    this.cachedStatsFrameCount = -1;\n\n    return frameId;\n  }\n\n  /**\n   * Search memories by query (uses fast lexical search)\n   */\n  async search(query: string, limit = 10): Promise<MemorySearchResult[]> {\n    return this.withLock(async () => {\n      return this.searchUnlocked(query, limit);\n    });\n  }\n\n  private async searchUnlocked(query: string, limit: number): Promise<MemorySearchResult[]> {\n    const results = await this.memvid.find(query, { k: limit, mode: \"lex\" });\n\n    const frames = this.toSearchFrames(results);\n\n    return frames.map((frame: any) => {\n      const rawTags = Array.isArray(frame.tags)\n        ? frame.tags.filter((tag: unknown): tag is string => typeof tag === \"string\")\n        : [];\n      const prefixedToolTag = rawTags.find((tag: string) => tag.startsWith(\"tool:\"));\n\n      const labels = Array.isArray(frame.labels)\n        ? frame.labels.filter((label: unknown): label is string => typeof label === \"string\")\n        : [];\n\n      const metadata = frame.metadata && typeof frame.metadata === \"object\"\n        ? frame.metadata as Record<string, unknown>\n        : {};\n\n      const observationType = this.extractObservationType({\n        label: frame.label,\n        labels,\n      }) || \"discovery\";\n\n      const legacyToolTag = rawTags.find((tag: string) => {\n        if (tag.startsWith(\"tool:\") || tag.startsWith(\"session:\")) {\n          return false;\n        }\n        if (!/[A-Z]/.test(tag)) {\n          return false;\n        }\n        return tag.toLowerCase() !== observationType;\n      });\n\n      const tool = typeof prefixedToolTag === \"string\"\n        ? prefixedToolTag.replace(/^tool:/, \"\")\n        : typeof metadata.tool === \"string\"\n          ? metadata.tool\n          : legacyToolTag;\n\n      const timestamp = this.normalizeTimestampMs(\n        metadata.timestamp\n        || frame.timestamp\n        || (typeof frame.created_at === \"string\" ? Date.parse(frame.created_at) : 0)\n      );\n\n      return {\n      observation: {\n        id: String(metadata.observationId || frame.frame_id || generateId()),\n        timestamp,\n        type: observationType,\n        tool,\n        summary: frame.title?.replace(/^\\[.*?\\]\\s*/, \"\") || frame.snippet || \"\",\n        content: frame.text || frame.snippet || \"\",\n        metadata: {\n          ...metadata,\n          labels,\n          tags: rawTags,\n        },\n      },\n      score: frame.score || 0,\n      snippet: frame.snippet || frame.text?.slice(0, 200) || \"\",\n    };\n    });\n  }\n\n  private toTimelineFrames(timelineResult: any): any[] {\n    return Array.isArray(timelineResult) ? timelineResult : (timelineResult.frames || []);\n  }\n\n  private toSearchFrames(searchResult: any): any[] {\n    if (Array.isArray(searchResult?.hits)) {\n      return searchResult.hits;\n    }\n    if (Array.isArray(searchResult?.frames)) {\n      return searchResult.frames;\n    }\n    return [];\n  }\n\n  private normalizeTimestampMs(value: unknown): number {\n    if (typeof value !== \"number\" || !Number.isFinite(value) || value <= 0) {\n      return 0;\n    }\n\n    // normalizeTimestampMs heuristic: 4102444800 is 2100-01-01 in epoch seconds.\n    // Values below 4102444800 are treated as seconds (SDK timeline fields can be\n    // second-based), so we multiply by 1000 to normalize to milliseconds.\n    if (value < 4102444800) {\n      return Math.round(value * 1000);\n    }\n\n    return Math.round(value);\n  }\n\n  private parseSessionSummary(value: unknown): SessionSummary | null {\n    if (!value || typeof value !== \"object\") {\n      return null;\n    }\n\n    const candidate = value as Record<string, unknown>;\n    if (\n      typeof candidate.id !== \"string\" ||\n      typeof candidate.startTime !== \"number\" ||\n      typeof candidate.endTime !== \"number\" ||\n      typeof candidate.observationCount !== \"number\" ||\n      typeof candidate.summary !== \"string\" ||\n      !Array.isArray(candidate.keyDecisions) ||\n      !Array.isArray(candidate.filesModified)\n    ) {\n      return null;\n    }\n\n    return {\n      id: candidate.id,\n      startTime: this.normalizeTimestampMs(candidate.startTime),\n      endTime: this.normalizeTimestampMs(candidate.endTime),\n      observationCount: Math.max(0, Math.trunc(candidate.observationCount)),\n      keyDecisions: candidate.keyDecisions.filter(\n        (decision): decision is string => typeof decision === \"string\"\n      ),\n      filesModified: candidate.filesModified.filter(\n        (file): file is string => typeof file === \"string\"\n      ),\n      summary: candidate.summary,\n    };\n  }\n\n  private extractSessionSummary(frame: any): SessionSummary | null {\n    const fromMetadata = this.parseSessionSummary(frame.metadata);\n    if (fromMetadata) {\n      return fromMetadata;\n    }\n\n    if (typeof frame.text !== \"string\") {\n      return null;\n    }\n\n    try {\n      return this.parseSessionSummary(JSON.parse(frame.text));\n    } catch {\n      return null;\n    }\n  }\n\n  private extractSessionId(frame: any): string | null {\n    const tags = Array.isArray(frame?.tags)\n      ? frame.tags.filter((tag: unknown): tag is string => typeof tag === \"string\")\n      : [];\n    const sessionTag = tags.find((tag: string) => tag.startsWith(\"session:\"));\n    if (sessionTag) {\n      return sessionTag.slice(\"session:\".length);\n    }\n\n    const metadataSessionId = frame?.metadata?.sessionId;\n    if (typeof metadataSessionId === \"string\" && metadataSessionId.length > 0) {\n      return metadataSessionId;\n    }\n\n    if (frame?.label === \"session\") {\n      const summary = this.extractSessionSummary(frame);\n      if (summary) {\n        return summary.id;\n      }\n    }\n\n    return null;\n  }\n\n  private extractObservationType(frame: any): ObservationType | null {\n    if (Array.isArray(frame?.labels)) {\n      for (const value of frame.labels) {\n        if (typeof value === \"string\") {\n          const normalized = value.toLowerCase();\n          if (OBSERVATION_TYPE_SET.has(normalized as ObservationType)) {\n            return normalized as ObservationType;\n          }\n        }\n      }\n    }\n\n    const label = typeof frame?.label === \"string\" ? frame.label : undefined;\n    if (label) {\n      const normalized = label.toLowerCase();\n      if (OBSERVATION_TYPE_SET.has(normalized as ObservationType)) {\n        return normalized as ObservationType;\n      }\n    }\n\n    const metadataType = frame?.metadata?.type;\n    if (typeof metadataType === \"string\") {\n      const normalized = metadataType.toLowerCase();\n      if (OBSERVATION_TYPE_SET.has(normalized as ObservationType)) {\n        return normalized as ObservationType;\n      }\n    }\n\n    return null;\n  }\n\n  private extractPreviewFieldValues(preview: unknown, field: \"tags\" | \"labels\"): string[] {\n    if (typeof preview !== \"string\" || preview.length === 0) {\n      return [];\n    }\n\n    const match = new RegExp(`(?:^|\\\\n)${field}:\\\\s*([^\\\\n]*)`, \"i\").exec(preview);\n    if (!match?.[1]) {\n      return [];\n    }\n\n    return match[1]\n      .split(/[^a-z0-9:_-]+/i)\n      .map((value) => value.trim())\n      .filter(Boolean);\n  }\n\n  private extractObservationTypeFromPreview(preview: unknown): ObservationType | null {\n    const labels = this.extractPreviewFieldValues(preview, \"labels\");\n    const fromLabels = this.extractObservationType({ labels });\n    if (fromLabels) {\n      return fromLabels;\n    }\n\n    if (typeof preview !== \"string\" || preview.length === 0) {\n      return null;\n    }\n\n    const titleMatch = /(?:^|\\n)title:\\s*\\[([^\\]]+)\\]/i.exec(preview);\n    if (!titleMatch?.[1]) {\n      return null;\n    }\n\n    const normalized = titleMatch[1].trim().toLowerCase();\n    if (OBSERVATION_TYPE_SET.has(normalized as ObservationType)) {\n      return normalized as ObservationType;\n    }\n\n    return null;\n  }\n\n  private parseLeadingJsonObject(text: string): unknown | null {\n    const start = text.indexOf(\"{\");\n    if (start < 0) {\n      return null;\n    }\n\n    let depth = 0;\n    let inString = false;\n    let escaped = false;\n\n    for (let i = start; i < text.length; i++) {\n      const ch = text[i];\n\n      if (inString) {\n        if (escaped) {\n          escaped = false;\n        } else if (ch === \"\\\\\") {\n          escaped = true;\n        } else if (ch === '\"') {\n          inString = false;\n        }\n        continue;\n      }\n\n      if (ch === '\"') {\n        inString = true;\n        continue;\n      }\n\n      if (ch === \"{\") {\n        depth += 1;\n      } else if (ch === \"}\") {\n        depth -= 1;\n        if (depth === 0) {\n          const candidate = text.slice(start, i + 1);\n          try {\n            return JSON.parse(candidate);\n          } catch {\n            return null;\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  private extractSessionSummaryFromSearchHit(hit: any): SessionSummary | null {\n    if (typeof hit?.text !== \"string\") {\n      return null;\n    }\n\n    const parsed = this.parseLeadingJsonObject(hit.text);\n    return this.parseSessionSummary(parsed);\n  }\n\n  /**\n   * Ask the memory a question (uses fast lexical search)\n   */\n  async ask(question: string): Promise<string> {\n    return this.withLock(async () => {\n      const result = await this.memvid.ask(question, { k: 5, mode: \"lex\" });\n      return result.answer || \"No relevant memories found.\";\n    });\n  }\n\n  /**\n   * Get context for session start\n   */\n  async getContext(query?: string): Promise<InjectedContext> {\n    return this.withLock(async () => {\n      // Get recent observations via timeline\n      const timeline = await this.memvid.timeline({\n        limit: this.config.maxContextObservations,\n        reverse: true,\n      });\n\n      const frames = this.toTimelineFrames(timeline);\n\n      const recentObservations: Observation[] = [];\n      const FRAME_INFO_BATCH_SIZE = 20;\n      for (let start = 0; start < frames.length; start += FRAME_INFO_BATCH_SIZE) {\n        const batch = frames.slice(start, start + FRAME_INFO_BATCH_SIZE);\n        const frameInfos = await Promise.all(batch.map(async (frame: any) => {\n          try {\n            return await this.memvid.getFrameInfo(frame.frame_id);\n          } catch {\n            return null;\n          }\n        }));\n\n        for (let index = 0; index < batch.length; index++) {\n          const frame = batch[index];\n          const frameInfo = frameInfos[index];\n          const labels = Array.isArray(frameInfo?.labels) ? frameInfo.labels : [];\n          const tags = Array.isArray(frameInfo?.tags) ? frameInfo.tags : [];\n          const metadata = frameInfo?.metadata && typeof frameInfo.metadata === \"object\"\n            ? frameInfo.metadata as Record<string, unknown>\n            : {};\n          const toolTag = tags.find((tag: string) => typeof tag === \"string\" && tag.startsWith(\"tool:\"));\n          const ts = this.normalizeTimestampMs(frameInfo?.timestamp || frame.timestamp || 0);\n          const observationType = this.extractObservationType({\n            label: labels[0],\n            labels,\n            metadata,\n          }) || \"discovery\";\n\n          recentObservations.push({\n            id: String(metadata.observationId || frame.metadata?.observationId || frame.frame_id),\n            timestamp: ts,\n            type: observationType,\n            tool: typeof toolTag === \"string\"\n              ? toolTag.replace(/^tool:/, \"\")\n              : (typeof metadata.tool === \"string\" ? metadata.tool : undefined),\n            summary: frameInfo?.title?.replace(/^\\[.*?\\]\\s*/, \"\") || frame.preview?.slice(0, 100) || \"\",\n            content: frame.preview || \"\",\n            metadata: {\n              ...metadata,\n              labels,\n              tags,\n            },\n          });\n        }\n      }\n\n      // Get relevant memories if query provided\n      let relevantMemories: Observation[] = [];\n      if (query) {\n        const searchResults = await this.searchUnlocked(query, 10);\n        relevantMemories = searchResults.map((r) => r.observation);\n      }\n\n      const summarySearch = await this.memvid.find(\"Session Summary\", {\n        k: 20,\n        mode: \"lex\",\n      });\n      const summaryHits = this.toSearchFrames(summarySearch);\n      const seenSessionIds = new Set<string>();\n      const sessionSummaries: SessionSummary[] = [];\n\n      for (const hit of summaryHits) {\n        const summary = this.extractSessionSummaryFromSearchHit(hit);\n        if (!summary || seenSessionIds.has(summary.id)) {\n          continue;\n        }\n        seenSessionIds.add(summary.id);\n        sessionSummaries.push(summary);\n        if (sessionSummaries.length >= 5) {\n          break;\n        }\n      }\n\n      // Build context with token limit\n      const contextParts: string[] = [];\n      let tokenCount = 0;\n\n      // Add recent observations\n      for (const obs of recentObservations) {\n        const text = `[${obs.type}] ${obs.summary}`;\n        const tokens = estimateTokens(text);\n        if (tokenCount + tokens > this.config.maxContextTokens) break;\n        contextParts.push(text);\n        tokenCount += tokens;\n      }\n\n      return {\n        recentObservations,\n        relevantMemories,\n        sessionSummaries,\n        tokenCount,\n      };\n    });\n  }\n\n  /**\n   * Save a session summary\n   */\n  async saveSessionSummary(summary: {\n    keyDecisions: string[];\n    filesModified: string[];\n    summary: string;\n  }): Promise<string> {\n    return this.withLock(async () => {\n      const endTime = Date.now();\n      const sessionSummary: SessionSummary = {\n        id: this.sessionId,\n        startTime: this.sessionStartTime,\n        endTime,\n        observationCount: this.sessionObservationCount,\n        keyDecisions: summary.keyDecisions.slice(0, 20),\n        filesModified: summary.filesModified.slice(0, 50),\n        summary: summary.summary,\n      };\n\n      const frameId = await this.memvid.put({\n        title: `Session Summary: ${new Date().toISOString().split(\"T\")[0]}`,\n        label: \"session\",\n        text: JSON.stringify(sessionSummary, null, 2),\n        metadata: {\n          ...sessionSummary,\n          sessionId: this.sessionId,\n        },\n        tags: [\"session\", \"summary\", `session:${this.sessionId}`],\n      });\n\n      this.cachedStats = null;\n      this.cachedStatsFrameCount = -1;\n      return frameId;\n    });\n  }\n\n  /**\n   * Get memory statistics\n   */\n  async stats(): Promise<MindStats> {\n    return this.withLock(async () => {\n      const stats = await this.memvid.stats();\n      const totalFrames = Number(stats.frame_count) || 0;\n\n      if (this.cachedStats && this.cachedStatsFrameCount === totalFrames) {\n        return this.cachedStats;\n      }\n\n      const timeline = totalFrames > 0\n        ? await this.memvid.timeline({ limit: totalFrames, reverse: false })\n        : [];\n      const frames = this.toTimelineFrames(timeline);\n\n      const sessionIds = new Set<string>();\n      const topTypes = emptyTypeCounts();\n      let oldestMemory = 0;\n      let newestMemory = 0;\n\n      for (const frame of frames) {\n        const labels = this.extractPreviewFieldValues(frame.preview, \"labels\");\n        const tags = this.extractPreviewFieldValues(frame.preview, \"tags\");\n\n        const timestamp = this.normalizeTimestampMs(frame.timestamp || 0);\n        if (timestamp > 0) {\n          if (oldestMemory === 0 || timestamp < oldestMemory) {\n            oldestMemory = timestamp;\n          }\n          if (newestMemory === 0 || timestamp > newestMemory) {\n            newestMemory = timestamp;\n          }\n        }\n\n        const sessionId = this.extractSessionId({\n          ...frame,\n          labels,\n          tags,\n        });\n        if (sessionId) {\n          sessionIds.add(sessionId);\n        }\n\n        const observationType = this.extractObservationType({\n          ...frame,\n          label: labels[0],\n          labels,\n          tags,\n        }) || this.extractObservationTypeFromPreview(frame.preview);\n        if (observationType) {\n          topTypes[observationType] += 1;\n        }\n      }\n\n      const summarySearch = await this.memvid.find(\"Session Summary\", {\n        k: 50,\n        mode: \"lex\",\n      });\n      const summaryHits = this.toSearchFrames(summarySearch);\n      for (const hit of summaryHits) {\n        const summary = this.extractSessionSummaryFromSearchHit(hit);\n        if (summary) {\n          sessionIds.add(summary.id);\n        }\n      }\n\n      const result: MindStats = {\n        totalObservations: totalFrames,\n        totalSessions: sessionIds.size,\n        oldestMemory,\n        newestMemory,\n        fileSize: (stats.size_bytes as number) || 0,\n        topTypes,\n      };\n\n      this.cachedStats = result;\n      this.cachedStatsFrameCount = totalFrames;\n      return result;\n    });\n  }\n\n  /**\n   * Get the session ID\n   */\n  getSessionId(): string {\n    return this.sessionId;\n  }\n\n  /**\n   * Get the memory file path\n   */\n  getMemoryPath(): string {\n    return this.memoryPath;\n  }\n\n  /**\n   * Check if initialized\n   */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n}\n\n// Singleton instance for hooks\nlet mindInstance: Mind | null = null;\n\n/**\n * Get or create the Mind singleton\n */\nexport async function getMind(config?: Partial<MindConfig>): Promise<Mind> {\n  if (!mindInstance) {\n    mindInstance = await Mind.open(config);\n  }\n  return mindInstance;\n}\n\n/**\n * Reset the Mind singleton (for testing)\n */\nexport function resetMind(): void {\n  mindInstance = null;\n}\n","import type { PlatformAdapter } from \"./contract.js\";\n\nexport interface ReadonlyAdapterRegistry {\n  resolve(platform: string): PlatformAdapter | null;\n  listPlatforms(): string[];\n}\n\nexport class AdapterRegistry implements ReadonlyAdapterRegistry {\n  private adapters = new Map<string, PlatformAdapter>();\n\n  register(adapter: PlatformAdapter): void {\n    this.adapters.set(adapter.platform, adapter);\n  }\n\n  resolve(platform: string): PlatformAdapter | null {\n    return this.adapters.get(platform) || null;\n  }\n\n  listPlatforms(): string[] {\n    return [...this.adapters.keys()].sort();\n  }\n}\n","import { generateId } from \"../utils/helpers.js\";\n\nexport type PlatformEventType = \"session_start\" | \"tool_observation\" | \"session_stop\";\n\nexport interface PlatformProjectContext {\n  platformProjectId?: string;\n  canonicalPath?: string;\n  cwd?: string;\n}\n\nexport interface PlatformEventBase {\n  eventId: string;\n  eventType: PlatformEventType;\n  platform: string;\n  contractVersion: string;\n  sessionId: string;\n  timestamp: number;\n  projectContext: PlatformProjectContext;\n}\n\nexport interface SessionStartPayload {\n  hookEventName?: string;\n  permissionMode?: string;\n  transcriptPath?: string;\n}\n\nexport interface ToolObservationPayload {\n  toolName?: string;\n  toolInput?: Record<string, unknown>;\n  toolResponse?: unknown;\n}\n\nexport interface SessionStopPayload {\n  transcriptPath?: string;\n}\n\nexport interface SessionStartEvent extends PlatformEventBase {\n  eventType: \"session_start\";\n  payload: SessionStartPayload;\n}\n\nexport interface ToolObservationEvent extends PlatformEventBase {\n  eventType: \"tool_observation\";\n  payload: ToolObservationPayload;\n}\n\nexport interface SessionStopEvent extends PlatformEventBase {\n  eventType: \"session_stop\";\n  payload: SessionStopPayload;\n}\n\nexport type PlatformEvent = SessionStartEvent | ToolObservationEvent | SessionStopEvent;\n\nexport function createEventId(): string {\n  return generateId();\n}\n","import {\n  createEventId,\n  type SessionStartEvent,\n  type SessionStopEvent,\n  type ToolObservationEvent,\n} from \"../events.js\";\nimport type { PlatformAdapter } from \"../contract.js\";\nimport type { HookInput } from \"../../types.js\";\n\nconst CONTRACT_VERSION = \"1.0.0\";\n\nexport function createAdapter(platform: string): PlatformAdapter {\n  function projectContext(input: HookInput) {\n    return {\n      platformProjectId: input.project_id,\n      canonicalPath: input.cwd,\n      cwd: input.cwd,\n    };\n  }\n\n  return {\n    platform,\n    contractVersion: CONTRACT_VERSION,\n\n    normalizeSessionStart(input: HookInput): SessionStartEvent {\n      return {\n        eventId: createEventId(),\n        eventType: \"session_start\",\n        platform,\n        contractVersion: input.contract_version?.trim() || CONTRACT_VERSION,\n        sessionId: input.session_id,\n        timestamp: Date.now(),\n        projectContext: projectContext(input),\n        payload: {\n          hookEventName: input.hook_event_name,\n          permissionMode: input.permission_mode,\n          transcriptPath: input.transcript_path,\n        },\n      };\n    },\n\n    normalizeToolObservation(input: HookInput): ToolObservationEvent | null {\n      if (!input.tool_name) return null;\n      return {\n        eventId: createEventId(),\n        eventType: \"tool_observation\",\n        platform,\n        contractVersion: input.contract_version?.trim() || CONTRACT_VERSION,\n        sessionId: input.session_id,\n        timestamp: Date.now(),\n        projectContext: projectContext(input),\n        payload: {\n          toolName: input.tool_name,\n          toolInput: input.tool_input,\n          toolResponse: input.tool_response,\n        },\n      };\n    },\n\n    normalizeSessionStop(input: HookInput): SessionStopEvent {\n      return {\n        eventId: createEventId(),\n        eventType: \"session_stop\",\n        platform,\n        contractVersion: input.contract_version?.trim() || CONTRACT_VERSION,\n        sessionId: input.session_id,\n        timestamp: Date.now(),\n        projectContext: projectContext(input),\n        payload: {\n          transcriptPath: input.transcript_path,\n        },\n      };\n    },\n  };\n}\n","import { createAdapter } from \"./create-adapter.js\";\n\nexport const claudeAdapter = createAdapter(\"claude\");\n","import { createAdapter } from \"./create-adapter.js\";\n\nexport const opencodeAdapter = createAdapter(\"opencode\");\n","import type { HookInput } from \"../types.js\";\nimport type {\n  SessionStartEvent,\n  SessionStopEvent,\n  ToolObservationEvent,\n} from \"./events.js\";\n\nexport const SUPPORTED_ADAPTER_CONTRACT_MAJOR = 1;\n\nconst SEMVER_PATTERN = /^(\\d+)\\.(\\d+)\\.(\\d+)(?:[-+].*)?$/;\n\nexport interface ContractValidationResult {\n  compatible: boolean;\n  supportedMajor: number;\n  adapterMajor: number | null;\n  reason?: string;\n}\n\nexport function parseContractMajor(version: string): number | null {\n  const match = SEMVER_PATTERN.exec(version.trim());\n  if (!match) {\n    return null;\n  }\n  return Number(match[1]);\n}\n\nexport function validateAdapterContractVersion(\n  version: string,\n  supportedMajor = SUPPORTED_ADAPTER_CONTRACT_MAJOR\n): ContractValidationResult {\n  const adapterMajor = parseContractMajor(version);\n  if (adapterMajor === null) {\n    return {\n      compatible: false,\n      supportedMajor,\n      adapterMajor: null,\n      reason: \"invalid_contract_version\",\n    };\n  }\n\n  if (adapterMajor !== supportedMajor) {\n    return {\n      compatible: false,\n      supportedMajor,\n      adapterMajor,\n      reason: \"incompatible_contract_major\",\n    };\n  }\n\n  return {\n    compatible: true,\n    supportedMajor,\n    adapterMajor,\n  };\n}\n\nexport interface PlatformAdapter {\n  platform: string;\n  contractVersion: string;\n  normalizeSessionStart(input: HookInput): SessionStartEvent;\n  normalizeToolObservation(input: HookInput): ToolObservationEvent | null;\n  normalizeSessionStop(input: HookInput): SessionStopEvent;\n}\n","export const DIAGNOSTIC_RETENTION_DAYS = 30;\n\nexport type DiagnosticSeverity = \"warning\" | \"error\";\n\nexport interface AdapterDiagnostic {\n  diagnosticId: string;\n  timestamp: number;\n  platform: string;\n  errorType: string;\n  fieldNames?: string[];\n  severity: DiagnosticSeverity;\n  redacted: true;\n  retentionDays: number;\n  expiresAt: number;\n}\n","import { tmpdir } from \"node:os\";\nimport {\n  existsSync,\n  mkdirSync,\n  readFileSync,\n  rmSync,\n  renameSync,\n  writeFileSync,\n} from \"node:fs\";\nimport { dirname, resolve } from \"node:path\";\nimport lockfile from \"proper-lockfile\";\nimport { generateId } from \"../utils/helpers.js\";\nimport {\n  DIAGNOSTIC_RETENTION_DAYS,\n  type AdapterDiagnostic,\n  type DiagnosticSeverity,\n} from \"./diagnostics.js\";\n\nconst DAY_MS = 24 * 60 * 60 * 1000;\nconst DIAGNOSTIC_FILE_NAME = \"platform-diagnostics.json\";\nconst TEST_DIAGNOSTIC_FILE_NAME = `memvid-platform-diagnostics-${process.pid}.json`;\n\nexport interface CreateDiagnosticInput {\n  platform: string;\n  errorType: string;\n  fieldNames?: string[];\n  severity?: DiagnosticSeverity;\n  now?: number;\n}\n\nfunction sanitizeFieldNames(fieldNames: string[] | undefined): string[] | undefined {\n  if (!fieldNames || fieldNames.length === 0) {\n    return undefined;\n  }\n  return [...new Set(fieldNames)].slice(0, 20);\n}\n\nfunction resolveDiagnosticStorePath(): string {\n  const explicitPath = process.env.MEMVID_DIAGNOSTIC_PATH?.trim();\n  const projectDir = process.env.CLAUDE_PROJECT_DIR || process.cwd();\n\n  if (explicitPath) {\n    return resolve(projectDir, explicitPath);\n  }\n\n  if (process.env.VITEST) {\n    return resolve(tmpdir(), TEST_DIAGNOSTIC_FILE_NAME);\n  }\n\n  return resolve(projectDir, \".claude\", DIAGNOSTIC_FILE_NAME);\n}\n\nfunction isDiagnosticRecord(value: unknown): value is AdapterDiagnostic {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n\n  const record = value as Record<string, unknown>;\n  return (\n    typeof record.diagnosticId === \"string\" &&\n    typeof record.timestamp === \"number\" &&\n    typeof record.platform === \"string\" &&\n    typeof record.errorType === \"string\" &&\n    (record.fieldNames === undefined ||\n      (Array.isArray(record.fieldNames)\n        && record.fieldNames.every((name) => typeof name === \"string\"))) &&\n    (record.severity === \"warning\" || record.severity === \"error\") &&\n    record.redacted === true &&\n    typeof record.retentionDays === \"number\" &&\n    typeof record.expiresAt === \"number\"\n  );\n}\n\nfunction pruneExpired(records: AdapterDiagnostic[], now = Date.now()): AdapterDiagnostic[] {\n  return records.filter((record) => record.expiresAt > now);\n}\n\nclass DiagnosticPersistence {\n  readonly filePath: string;\n\n  constructor(filePath: string) {\n    this.filePath = filePath;\n  }\n\n  append(record: AdapterDiagnostic, now = Date.now()): void {\n    this.withFileLock(() => {\n      const latest = this.loadFromDisk();\n      const next = pruneExpired([...latest, record], now);\n      this.persist(next);\n    });\n  }\n\n  list(now = Date.now()): AdapterDiagnostic[] {\n    return this.withFileLock(() => {\n      const latest = this.loadFromDisk();\n      const pruned = pruneExpired(latest, now);\n      if (pruned.length !== latest.length) {\n        this.persist(pruned);\n      }\n      return [...pruned];\n    });\n  }\n\n  private loadFromDisk(): AdapterDiagnostic[] {\n    if (!existsSync(this.filePath)) {\n      return [];\n    }\n\n    try {\n      const raw = readFileSync(this.filePath, \"utf-8\").trim();\n      if (!raw) {\n        return [];\n      }\n\n      const parsed = JSON.parse(raw);\n      if (!Array.isArray(parsed)) {\n        return [];\n      }\n\n      return parsed.filter(isDiagnosticRecord);\n    } catch {\n      return [];\n    }\n  }\n\n  private withFileLock<T>(fn: () => T): T {\n    mkdirSync(dirname(this.filePath), { recursive: true });\n    const release = lockfile.lockSync(this.filePath, { realpath: false });\n    try {\n      return fn();\n    } finally {\n      release();\n    }\n  }\n\n  private persist(records: AdapterDiagnostic[]): void {\n    mkdirSync(dirname(this.filePath), { recursive: true });\n    const tmpPath = `${this.filePath}.tmp-${process.pid}-${Date.now()}`;\n    try {\n      writeFileSync(tmpPath, `${JSON.stringify(records, null, 2)}\\n`, \"utf-8\");\n      try {\n        renameSync(tmpPath, this.filePath);\n      } catch {\n        rmSync(this.filePath, { force: true });\n        renameSync(tmpPath, this.filePath);\n      }\n    } finally {\n      rmSync(tmpPath, { force: true });\n    }\n  }\n}\n\nlet persistence: DiagnosticPersistence | null = null;\nlet persistenceFilePath: string | null = null;\nlet warnedPathChange = false;\n\nfunction getDiagnosticPersistence(): DiagnosticPersistence {\n  const resolvedPath = resolveDiagnosticStorePath();\n\n  if (!persistence) {\n    persistence = new DiagnosticPersistence(resolvedPath);\n    persistenceFilePath = resolvedPath;\n    warnedPathChange = false;\n    return persistence;\n  }\n\n  if (persistenceFilePath && persistenceFilePath !== resolvedPath && !warnedPathChange) {\n    warnedPathChange = true;\n    console.error(\n      `[memvid-mind] Diagnostic store path changed from \"${persistenceFilePath}\" to \"${resolvedPath}\" after initialization; continuing with the original path.`\n    );\n  }\n\n  return persistence;\n}\n\nexport function resetDiagnosticPersistenceForTests(): void {\n  persistence = null;\n  persistenceFilePath = null;\n  warnedPathChange = false;\n}\n\nexport function listPersistedDiagnostics(now = Date.now()): AdapterDiagnostic[] {\n  return getDiagnosticPersistence().list(now);\n}\n\nexport function createRedactedDiagnostic(input: CreateDiagnosticInput): AdapterDiagnostic {\n  const timestamp = input.now ?? Date.now();\n  const diagnostic: AdapterDiagnostic = {\n    diagnosticId: generateId(),\n    timestamp,\n    platform: input.platform,\n    errorType: input.errorType,\n    fieldNames: sanitizeFieldNames(input.fieldNames),\n    severity: input.severity ?? \"warning\",\n    redacted: true,\n    retentionDays: DIAGNOSTIC_RETENTION_DAYS,\n    expiresAt: timestamp + (DIAGNOSTIC_RETENTION_DAYS * DAY_MS),\n  };\n\n  try {\n    getDiagnosticPersistence().append(diagnostic);\n  } catch {\n    // Fail-open: never block event processing on diagnostic persistence failures.\n  }\n\n  return diagnostic;\n}\n","import { resolve } from \"node:path\";\nimport type { PlatformProjectContext } from \"./events.js\";\n\nexport type ProjectIdentitySource =\n  | \"platform_project_id\"\n  | \"canonical_path\"\n  | \"unresolved\";\n\nexport interface ProjectIdentityResolution {\n  key: string | null;\n  source: ProjectIdentitySource;\n  canonicalPath?: string;\n}\n\nexport function resolveCanonicalProjectPath(\n  context: PlatformProjectContext\n): string | undefined {\n  if (context.canonicalPath) {\n    return resolve(context.canonicalPath);\n  }\n  if (context.cwd) {\n    return resolve(context.cwd);\n  }\n  return undefined;\n}\n\nexport function resolveProjectIdentityKey(\n  context: PlatformProjectContext\n): ProjectIdentityResolution {\n  if (context.platformProjectId && context.platformProjectId.trim().length > 0) {\n    return {\n      key: context.platformProjectId.trim(),\n      source: \"platform_project_id\",\n      canonicalPath: resolveCanonicalProjectPath(context),\n    };\n  }\n\n  const canonicalPath = resolveCanonicalProjectPath(context);\n  if (canonicalPath) {\n    return {\n      key: canonicalPath,\n      source: \"canonical_path\",\n      canonicalPath,\n    };\n  }\n\n  return {\n    key: null,\n    source: \"unresolved\",\n  };\n}\n","import {\n  SUPPORTED_ADAPTER_CONTRACT_MAJOR,\n  validateAdapterContractVersion,\n} from \"./contract.js\";\nimport { createRedactedDiagnostic } from \"./diagnostic-store.js\";\nimport type { AdapterDiagnostic } from \"./diagnostics.js\";\nimport type { PlatformEvent } from \"./events.js\";\nimport { resolveProjectIdentityKey } from \"./identity.js\";\n\nexport interface ProcessPlatformEventResult {\n  skipped: boolean;\n  reason?: string;\n  projectIdentityKey?: string;\n  diagnostic?: AdapterDiagnostic;\n}\n\nfunction skipWithDiagnostic(\n  platform: string,\n  errorType: string,\n  fieldNames?: string[]\n): ProcessPlatformEventResult {\n  return {\n    skipped: true,\n    reason: errorType,\n    diagnostic: createRedactedDiagnostic({\n      platform,\n      errorType,\n      fieldNames,\n      severity: \"warning\",\n    }),\n  };\n}\n\nexport function processPlatformEvent(\n  event: PlatformEvent\n): ProcessPlatformEventResult {\n  const contractValidation = validateAdapterContractVersion(\n    event.contractVersion,\n    SUPPORTED_ADAPTER_CONTRACT_MAJOR\n  );\n  if (!contractValidation.compatible) {\n    return skipWithDiagnostic(event.platform, contractValidation.reason ?? \"incompatible_contract\", [\"contractVersion\"]);\n  }\n\n  const identity = resolveProjectIdentityKey(event.projectContext);\n  if (!identity.key) {\n    return skipWithDiagnostic(event.platform, \"missing_project_identity\", [\n      \"platformProjectId\",\n      \"canonicalPath\",\n      \"cwd\",\n    ]);\n  }\n\n  return {\n    skipped: false,\n    projectIdentityKey: identity.key,\n  };\n}\n","import { AdapterRegistry } from \"./registry.js\";\nimport type { ReadonlyAdapterRegistry } from \"./registry.js\";\nimport { claudeAdapter, opencodeAdapter } from \"./adapters/index.js\";\n\nexport * from \"./contract.js\";\nexport * from \"./diagnostics.js\";\nexport * from \"./diagnostic-store.js\";\nexport * from \"./events.js\";\nexport * from \"./identity.js\";\nexport * from \"./path-policy.js\";\nexport * from \"./pipeline.js\";\nexport * from \"./platform-detector.js\";\nexport type { ReadonlyAdapterRegistry } from \"./registry.js\";\nexport { AdapterRegistry } from \"./registry.js\";\nexport * from \"./adapters/index.js\";\n\nlet defaultRegistry: ReadonlyAdapterRegistry | null = null;\n\nexport function getDefaultAdapterRegistry(): ReadonlyAdapterRegistry {\n  if (!defaultRegistry) {\n    const registry = new AdapterRegistry();\n    registry.register(claudeAdapter);\n    registry.register(opencodeAdapter);\n    defaultRegistry = Object.freeze({\n      resolve: (platform: string) => registry.resolve(platform),\n      listPlatforms: () => registry.listPlatforms(),\n    });\n  }\n\n  return defaultRegistry;\n}\n\nexport function resetDefaultAdapterRegistry(): void {\n  defaultRegistry = null;\n}\n","#!/usr/bin/env node\n/**\n * Memvid Mind - Stop Hook\n *\n * AUTO SESSION SUMMARY\n * Runs when Claude session ends.\n * Generates an intelligent session summary for future reference.\n *\n * WORKAROUND: Since PostToolUse doesn't fire for Edit operations (Claude Code bug),\n * we capture git diff at session end to record all file modifications.\n */\n\nimport { getMind } from \"../core/mind.js\";\nimport { readStdin, writeOutput, debug } from \"../utils/helpers.js\";\nimport type { HookInput, HookOutput } from \"../types.js\";\nimport {\n  detectPlatform,\n  getDefaultAdapterRegistry,\n  processPlatformEvent,\n} from \"../platforms/index.js\";\nimport { readFile, access } from \"node:fs/promises\";\nimport { constants, existsSync } from \"node:fs\";\nimport { dirname, join, resolve } from \"node:path\";\nimport { execSync } from \"node:child_process\";\nimport { fileURLToPath } from \"node:url\";\n\n// Minimum observations to generate a session summary\nconst MIN_OBSERVATIONS_FOR_SUMMARY = 3;\n\nfunction hasRepoMarker(path: string): boolean {\n  return existsSync(join(path, \".git\")) || existsSync(join(path, \"package.json\"));\n}\n\nfunction findNearestRepoRoot(startPath: string): string | null {\n  let current = resolve(startPath);\n  while (true) {\n    if (hasRepoMarker(current)) {\n      return current;\n    }\n\n    const parent = dirname(current);\n    if (parent === current) {\n      return null;\n    }\n\n    current = parent;\n  }\n}\n\nfunction findRepoRoot(memoryPath: string): string {\n  const candidates = [\n    process.env.REPO_ROOT,\n    process.env.CLAUDE_PROJECT_DIR,\n    process.env.OPENCODE_PROJECT_DIR,\n    dirname(memoryPath),\n    process.cwd(),\n  ]\n    .filter((candidate): candidate is string => typeof candidate === \"string\" && candidate.trim().length > 0)\n    .map((candidate) => resolve(candidate));\n\n  for (const candidate of candidates) {\n    const repoRoot = findNearestRepoRoot(candidate);\n    if (repoRoot) {\n      return repoRoot;\n    }\n  }\n\n  return resolve(dirname(memoryPath));\n}\n\n/**\n * Capture file modifications at session end\n * WORKAROUND for Claude Code bug: PostToolUse hooks don't fire for Edit operations\n *\n * Captures both:\n * 1. Git tracked files that changed (git diff)\n * 2. Recently modified files in untracked directories (find -mmin)\n */\nasync function captureFileChanges(mind: Awaited<ReturnType<typeof getMind>>) {\n  try {\n    // Get the working directory from the mind's memory path\n    const memoryPath = mind.getMemoryPath();\n    const workDir = findRepoRoot(memoryPath);\n\n    const allChangedFiles: string[] = [];\n    let gitDiffContent = \"\";\n\n    // 1. Get git tracked changes (staged and unstaged)\n    // Use shorter timeouts to avoid blocking session end\n    try {\n      const diffNames = execSync(\"git diff --name-only HEAD 2>/dev/null || git diff --name-only 2>/dev/null || echo ''\", {\n        cwd: workDir,\n        encoding: \"utf-8\",\n        timeout: 3000,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      }).trim();\n\n      const stagedNames = execSync(\"git diff --cached --name-only 2>/dev/null || echo ''\", {\n        cwd: workDir,\n        encoding: \"utf-8\",\n        timeout: 3000,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      }).trim();\n\n      const gitFiles = [...new Set([\n        ...diffNames.split(\"\\n\").filter(Boolean),\n        ...stagedNames.split(\"\\n\").filter(Boolean),\n      ])];\n\n      allChangedFiles.push(...gitFiles);\n\n      // Get git diff stat for tracked files\n      if (gitFiles.length > 0) {\n        try {\n          gitDiffContent = execSync(\"git diff HEAD --stat 2>/dev/null | head -30\", {\n            cwd: workDir,\n            encoding: \"utf-8\",\n            timeout: 3000,\n            stdio: ['pipe', 'pipe', 'pipe'],\n          }).trim();\n        } catch {\n          // Ignore\n        }\n      }\n    } catch {\n      // Not a git repo or git not available - continue to find recent files\n    }\n\n    // 2. Find recently modified files (last 30 minutes) in common code directories\n    // This catches changes in untracked directories\n    // Use -maxdepth to limit search and exclude common large dirs for speed\n    // Reduced timeout and scope to avoid hanging\n    try {\n      const recentFiles = execSync(\n        `find . -maxdepth 4 -type f \\\\( -name \"*.ts\" -o -name \"*.tsx\" -o -name \"*.js\" -o -name \"*.jsx\" -o -name \"*.md\" -o -name \"*.json\" -o -name \"*.py\" -o -name \"*.rs\" \\\\) -mmin -30 ! -path \"*/node_modules/*\" ! -path \"*/.git/*\" ! -path \"*/dist/*\" ! -path \"*/build/*\" ! -path \"*/.next/*\" ! -path \"*/target/*\" 2>/dev/null | head -30`,\n        {\n          cwd: workDir,\n          encoding: \"utf-8\",\n          timeout: 5000,\n          stdio: ['pipe', 'pipe', 'pipe'],\n        }\n      ).trim();\n\n      const recentFilesList = recentFiles.split(\"\\n\").filter(Boolean).map(f => f.replace(/^\\.\\//, \"\"));\n\n      // Add files not already in the list\n      for (const file of recentFilesList) {\n        if (!allChangedFiles.includes(file)) {\n          allChangedFiles.push(file);\n        }\n      }\n    } catch {\n      // find command failed, continue with what we have\n    }\n\n    if (allChangedFiles.length === 0) {\n      debug(\"No file changes detected\");\n      return;\n    }\n\n    debug(`Capturing ${allChangedFiles.length} changed files`);\n\n    // Build content summary\n    const contentParts = [`## Files Modified This Session\\n\\n${allChangedFiles.map(f => `- ${f}`).join(\"\\n\")}`];\n\n    if (gitDiffContent) {\n      contentParts.push(`\\n## Git Changes Summary\\n\\`\\`\\`\\n${gitDiffContent}\\n\\`\\`\\``);\n    }\n\n    // Store the changes as a memory\n    await mind.remember({\n      type: \"refactor\",\n      summary: `Session edits: ${allChangedFiles.length} file(s) modified`,\n      content: contentParts.join(\"\\n\"),\n      tool: \"FileChanges\",\n      metadata: {\n        files: allChangedFiles,\n        fileCount: allChangedFiles.length,\n        captureMethod: \"git-diff-plus-recent\",\n      },\n    });\n\n    // Also store individual entries for important file types (README, config, etc.)\n    // so they're searchable by name\n    for (const file of allChangedFiles) {\n      const fileName = file.split(\"/\").pop() || file;\n      const isImportant = /^(README|CHANGELOG|package\\.json|Cargo\\.toml|\\.env)/i.test(fileName);\n\n      if (isImportant) {\n        await mind.remember({\n          type: \"refactor\",\n          summary: `Modified ${fileName}`,\n          content: `File edited: ${file}\\nThis file was modified during the session.`,\n          tool: \"FileEdit\",\n          metadata: {\n            files: [file],\n            fileName,\n          },\n        });\n        debug(`Stored individual edit: ${fileName}`);\n      }\n    }\n\n    debug(`Stored file changes: ${allChangedFiles.length} files`);\n  } catch (error) {\n    debug(`Failed to capture file changes: ${error}`);\n  }\n}\n\nexport async function runStopHook(): Promise<void> {\n  try {\n    // Read hook input from stdin\n    const input = await readStdin();\n    const hookInput: HookInput = JSON.parse(input);\n\n    debug(`Session stopping: ${hookInput.session_id}`);\n\n    const platform = detectPlatform(hookInput);\n    const adapter = getDefaultAdapterRegistry().resolve(platform);\n    if (!adapter) {\n      debug(`Unsupported platform at stop hook: ${platform}`);\n      writeOutput({ continue: true });\n      return;\n    }\n\n    const normalizedStop = adapter.normalizeSessionStop(hookInput);\n    const pipelineResult = processPlatformEvent(normalizedStop);\n    if (pipelineResult.skipped) {\n      debug(`Skipping stop processing: ${pipelineResult.reason}`);\n      writeOutput({ continue: true });\n      return;\n    }\n\n    // Initialize mind\n    const mind = await getMind();\n    const stats = await mind.stats();\n\n    // WORKAROUND: Capture file changes since PostToolUse doesn't fire for Edit\n    await captureFileChanges(mind);\n\n    // Try to read the transcript for richer summary\n    let transcriptContent = \"\";\n    if (hookInput.transcript_path) {\n      try {\n        await access(hookInput.transcript_path, constants.R_OK);\n        transcriptContent = await readFile(hookInput.transcript_path, \"utf-8\");\n      } catch {\n        // Transcript not available, that's ok\n      }\n    }\n\n    // Get recent observations from this session\n    const context = await mind.getContext();\n    const sessionObservations = context.recentObservations.filter(\n      (obs) => obs.metadata?.sessionId === mind.getSessionId()\n    );\n\n    // Generate session summary if we have enough observations\n    if (sessionObservations.length >= MIN_OBSERVATIONS_FOR_SUMMARY) {\n      const summary = generateSessionSummary(\n        sessionObservations,\n        transcriptContent\n      );\n\n      // Save the session summary\n      await mind.saveSessionSummary(summary);\n\n      debug(\n        `Session summary saved: ${summary.keyDecisions.length} decisions, ${summary.filesModified.length} files`\n      );\n    }\n\n    debug(\n      `Session complete. Total memories: ${stats.totalObservations}, File: ${mind.getMemoryPath()}`\n    );\n\n    // Continue without blocking\n    const output: HookOutput = {\n      continue: true,\n    };\n\n    writeOutput(output);\n  } catch (error) {\n    debug(`Error: ${error}`);\n    // Don't block on errors\n    writeOutput({ continue: true });\n  }\n}\n\n/**\n * Generate a session summary from observations\n */\nfunction generateSessionSummary(\n  observations: Array<{\n    type: string;\n    summary: string;\n    content: string;\n    metadata?: { files?: string[]; sessionId?: string; [key: string]: unknown };\n  }>,\n  transcript: string\n): {\n  keyDecisions: string[];\n  filesModified: string[];\n  summary: string;\n} {\n  // Extract key decisions\n  const keyDecisions: string[] = [];\n  const filesModified = new Set<string>();\n\n  for (const obs of observations) {\n    // Track decisions\n    if (\n      obs.type === \"decision\" ||\n      obs.summary.toLowerCase().includes(\"chose\") ||\n      obs.summary.toLowerCase().includes(\"decided\")\n    ) {\n      keyDecisions.push(obs.summary);\n    }\n\n    // Track files from metadata\n    const files = obs.metadata?.files as string[] | undefined;\n    if (files) {\n      files.forEach((f) => filesModified.add(f));\n    }\n  }\n\n  // Extract file paths from transcript if available\n  if (transcript) {\n    const filePatterns = [\n      /(?:Read|Edit|Write)[^\"]*\"([^\"]+)\"/g,\n      /file_path[\"\\s:]+([^\\s\"]+)/g,\n    ];\n\n    for (const pattern of filePatterns) {\n      let match;\n      while ((match = pattern.exec(transcript)) !== null) {\n        const path = match[1];\n        if (path && !path.includes(\"node_modules\") && !path.startsWith(\".\")) {\n          filesModified.add(path);\n        }\n      }\n    }\n  }\n\n  // Generate summary based on observation types\n  const typeCounts: Record<string, number> = {};\n  for (const obs of observations) {\n    typeCounts[obs.type] = (typeCounts[obs.type] || 0) + 1;\n  }\n\n  const summaryParts: string[] = [];\n\n  if (typeCounts.feature) {\n    summaryParts.push(`Added ${typeCounts.feature} feature(s)`);\n  }\n  if (typeCounts.bugfix) {\n    summaryParts.push(`Fixed ${typeCounts.bugfix} bug(s)`);\n  }\n  if (typeCounts.refactor) {\n    summaryParts.push(`Refactored ${typeCounts.refactor} item(s)`);\n  }\n  if (typeCounts.discovery) {\n    summaryParts.push(`Made ${typeCounts.discovery} discovery(ies)`);\n  }\n  if (typeCounts.problem) {\n    summaryParts.push(`Encountered ${typeCounts.problem} problem(s)`);\n  }\n  if (typeCounts.solution) {\n    summaryParts.push(`Found ${typeCounts.solution} solution(s)`);\n  }\n\n  const summary =\n    summaryParts.length > 0\n      ? summaryParts.join(\". \") + \".\"\n      : `Session with ${observations.length} observations.`;\n\n  return {\n    keyDecisions: keyDecisions.slice(0, 10),\n    filesModified: Array.from(filesModified).slice(0, 20),\n    summary,\n  };\n}\n\nif (process.argv[1] && fileURLToPath(import.meta.url) === process.argv[1]) {\n  void runStopHook();\n}\n"]}